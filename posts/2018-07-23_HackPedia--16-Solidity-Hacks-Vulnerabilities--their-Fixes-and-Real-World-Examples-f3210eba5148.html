<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World Examples</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World Examples</h1>
</header>
<section data-field="subtitle" class="p-summary">
A Complete List of all Solidity Hacks/Vulnerabilities, their Fixes and Real World Hack Examples
</section>
<section data-field="body" class="e-content">
<section name="68c4" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9cf8" id="9cf8" class="graf graf--h3 graf--leading graf--title">HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World Examples</h3><h4 name="8e1e" id="8e1e" class="graf graf--h4 graf-after--h3 graf--subtitle">A Complete List of all Solidity Hacks/Vulnerabilities, their Fixes and Real World Hack Examples</h4></div><div class="section-inner sectionLayout--fullWidth"><figure name="08f6" id="08f6" class="graf graf--figure graf--layoutFillWidth graf-after--h4"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 62.5%;"></div><img class="graf-image" data-image-id="1*cgEAk9Z51Qi39saBRCJ1Pg.jpeg" data-width="1440" data-height="900" src="https://cdn-images-1.medium.com/max/2560/1*cgEAk9Z51Qi39saBRCJ1Pg.jpeg"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="4cfd" id="4cfd" class="graf graf--p graf-after--figure">This blog was written by <em class="markup--em markup--p-em">Dr. Adrian Manning</em> in this <a href="https://blog.sigmaprime.io/solidity-security.html" data-href="https://blog.sigmaprime.io/solidity-security.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SigmaPrime Blog</a>.</p><p name="4106" id="4106" class="graf graf--p graf-after--p">Although in its infancy, Solidity has had widespread adoption and is used to compile the byte-code in many Ethereum smart contracts we see today. There have been a number of harsh lessons learned by developers and users alike in discovering the nuances of the language and the EVM. This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity developers in an effort to prevent future devs from repeating history.</p><p name="237f" id="237f" class="graf graf--p graf-after--p">Here are 16 interesting hacks:</p><h3 name="7dd7" id="7dd7" class="graf graf--h3 graf-after--p">1. Re-Entrancy</h3><p name="e83c" id="e83c" class="graf graf--p graf-after--h3">One of the features of Ethereum smart contracts is the ability to call and utilise code of other external contracts. Contracts also typically handle ether, and as such often send ether to various external user addresses. The operation of calling external contracts, or sending ether to an address, requires the contract to submit an external call. These external calls can be hijacked by attackers whereby they force the contract to execute further code (i.e. through a fallback function) , including calls back into itself. Thus the code execution “<em class="markup--em markup--p-em">re-enters</em>” the contract. Attacks of this kind were used in the infamous DAO hack.</p><p name="e784" id="e784" class="graf graf--p graf-after--p">For further reading on re-entrancy attacks, see <a href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4" data-href="https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">Reentrancy Attack On Smart Contracts</a> and <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" data-href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Consensus — Ethereum Smart Contract Best Practices</a>.</p><h3 name="fecf" id="fecf" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="1e1b" id="1e1b" class="graf graf--p graf-after--h3">This attack can occur when a contract sends ether to an unknown address. An attacker can carefully construct a contract at an external address which contains malicious code in the <a href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function" data-href="https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">fallback function</a>. Thus, when a contract sends ether to this address, it will invoke the malicious code. Typically the malicious code executes a function on the vulnerable contract, performing operations not expected by the developer. The name “re-entrancy” comes from the fact that the external malicious contract calls back a function on the vulnerable contract and “<em class="markup--em markup--p-em">re-enters</em>” code execution at an arbitrary location on the vulnerable contract.</p><p name="e22b" id="e22b" class="graf graf--p graf-after--p">To clarify this, consider the simple vulnerable contract, which acts as an Ethereum vault that allows depositors to only withdraw 1 ether per week.</p><h4 name="a903" id="a903" class="graf graf--h4 graf-after--p">EtherStore.sol</h4><figure name="3439" id="3439" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/01f8a36a9129fd43e1ced7eb7769c341.js"></script></figure><p name="c32f" id="c32f" class="graf graf--p graf-after--figure">This contract has two public functions. <code class="markup--code markup--p-code">depositFunds()</code> and <code class="markup--code markup--p-code">withdrawFunds()</code>. The <code class="markup--code markup--p-code">depositFunds()</code> function simply increments the senders balances. The <code class="markup--code markup--p-code">withdrawFunds()</code> function allows the sender to specify the amount of wei to withdraw. It will only succeed if the requested amount to withdraw is less than 1 ether and a withdrawal hasn&#39;t occurred in the last week. Or does it?...</p><p name="4325" id="4325" class="graf graf--p graf-after--p">The vulnerability comes on line [17] where we send the user their requested amount of ether. Consider a malicious attacker creating the following contract,</p><h4 name="503e" id="503e" class="graf graf--h4 graf-after--p">Attack.sol</h4><figure name="dd77" id="dd77" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/e556e34c2c4b5ba9220135eec4eefb70.js"></script></figure><p name="6fbc" id="6fbc" class="graf graf--p graf-after--figure">Let us see how this malicious contract can exploit our <code class="markup--code markup--p-code">EtherStore</code> contract. The attacker would create the above contract (let&#39;s say at the address <code class="markup--code markup--p-code">0x0...123</code>) with the <code class="markup--code markup--p-code">EtherStore</code>&#39;s contract address as the constructor parameter. This will initialize and point the public variable <code class="markup--code markup--p-code">etherStore</code> to the contract we wish to attack.</p><p name="2606" id="2606" class="graf graf--p graf-after--p">The attacker would then call the <code class="markup--code markup--p-code">pwnEtherStore()</code> function, with some amount of ether (greater than or equal to 1), lets say <code class="markup--code markup--p-code">1 ether</code> for this example. In this example we assume a number of other users have deposited ether into this contract, such that it&#39;s current balance is <code class="markup--code markup--p-code">10 ether</code>. The following would then occur:</p><ol class="postList"><li name="1b50" id="1b50" class="graf graf--li graf-after--p">Attack.sol — Line [15] — The <code class="markup--code markup--li-code">depositFunds()</code> function of the EtherStore contract will be called with a <code class="markup--code markup--li-code">msg.value</code> of <code class="markup--code markup--li-code">1 ether</code> (and a lot of gas). The sender (<code class="markup--code markup--li-code">msg.sender</code>) will be our malicious contract (<code class="markup--code markup--li-code">0x0...123</code>). Thus, <code class="markup--code markup--li-code">balances[0x0..123] = 1 ether</code>.</li><li name="5ebd" id="5ebd" class="graf graf--li graf-after--li">Attack.sol — Line [17] — The malicious contract will then call the <code class="markup--code markup--li-code">withdrawFunds()</code> function of the <code class="markup--code markup--li-code">EtherStore</code> contract with a parameter of <code class="markup--code markup--li-code">1 ether</code>. This will pass all the requirements (Lines [12]-[16] of the <code class="markup--code markup--li-code">EtherStore</code> contract) as we have made no previous withdrawals.</li><li name="1169" id="1169" class="graf graf--li graf-after--li">EtherStore.sol — Line [17] — The contract will then send <code class="markup--code markup--li-code">1 ether</code> back to the malicious contract.</li><li name="79d2" id="79d2" class="graf graf--li graf-after--li">Attack.sol — Line [25] — The ether sent to the malicious contract will then execute the fallback function.</li><li name="ed85" id="ed85" class="graf graf--li graf-after--li">Attack.sol — Line [26] — The total balance of the EtherStore contract was <code class="markup--code markup--li-code">10 ether</code> and is now <code class="markup--code markup--li-code">9 ether</code> so this if statement passes.</li><li name="b945" id="b945" class="graf graf--li graf-after--li">Attack.sol — Line [27] — The fallback function then calls the <code class="markup--code markup--li-code">EtherStore</code> <code class="markup--code markup--li-code">withdrawFunds()</code> function again and &quot;<em class="markup--em markup--li-em">re-enters</em>&quot; the <code class="markup--code markup--li-code">EtherStore</code> contract.</li><li name="ff2c" id="ff2c" class="graf graf--li graf-after--li">EtherStore.sol — Line [11] — In this second call to <code class="markup--code markup--li-code">withdrawFunds()</code>, our balance is still <code class="markup--code markup--li-code">1 ether</code> as line [18] has not yet been executed. Thus, we still have <code class="markup--code markup--li-code">balances[0x0..123] = 1 ether</code>. This is also the case for the <code class="markup--code markup--li-code">lastWithdrawTime</code>variable. Again, we pass all the requirements.</li><li name="0717" id="0717" class="graf graf--li graf-after--li">EtherStore.sol — Line [17] — We withdraw another <code class="markup--code markup--li-code">1 ether</code>.</li><li name="4729" id="4729" class="graf graf--li graf-after--li">Steps 4–8 will repeat — until <code class="markup--code markup--li-code">EtherStore.balance &gt;= 1</code> as dictated by line [26] in <code class="markup--code markup--li-code">Attack.sol</code>.</li><li name="4632" id="4632" class="graf graf--li graf-after--li">Attack.sol — Line [26] — Once there less 1 (or less) ether left in the <code class="markup--code markup--li-code">EtherStore</code> contract, this if statement will fail. This will then allow lines [18] and [19] of the <code class="markup--code markup--li-code">EtherStore</code> contract to be executed (for each call to the <code class="markup--code markup--li-code">withdrawFunds()</code> function).</li><li name="5d2f" id="5d2f" class="graf graf--li graf-after--li">EtherStore.sol — Lines [18] and [19] — The <code class="markup--code markup--li-code">balances</code> and <code class="markup--code markup--li-code">lastWithdrawTime</code> mappings will be set and the execution will end.</li></ol><p name="7ef1" id="7ef1" class="graf graf--p graf-after--li">The final result, is that the attacker has withdrawn all (bar 1) ether from the <code class="markup--code markup--p-code">EtherStore</code> contract, instantaneously with a single transaction.</p><h3 name="5aec" id="5aec" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="1b27" id="1b27" class="graf graf--p graf-after--h3">There are a number of common techniques which help avoid potential re-entrancy vulnerabilities in smart contracts. The first is to ( whenever possible) use the built-in <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related" data-href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">transfer()</a> function when sending ether to external contracts. The transfer function only sends <code class="markup--code markup--p-code">2300 gas</code> which isn&#39;t enough for the destination address/contract to call another contract (i.e. re-enter the sending contract).</p><p name="d206" id="d206" class="graf graf--p graf-after--p">The second technique is to ensure that all logic that changes state variables happen before ether is sent out of the contract (or any external call). In the <code class="markup--code markup--p-code">EtherStore</code> example, lines [18] and [19] of <code class="markup--code markup--p-code">EtherStore.sol</code> should be put before line [17]. It is good practice to place any code that performs external calls to unknown addresses as the last operation in a localised function or piece of code execution. This is known as the <a href="http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern" data-href="http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">checks-effects-interactions</a> pattern.</p><p name="bff4" id="bff4" class="graf graf--p graf-after--p">A third technique is to introduce a mutex. That is, to add a state variable which locks the contract during code execution, preventing reentrancy calls.</p><p name="4b67" id="4b67" class="graf graf--p graf-after--p">Applying all of these techniques (all three are unnecessary, but is done for demonstrative purposes) to <code class="markup--code markup--p-code">EtherStore.sol</code>, gives the re-entrancy-free contract:</p><figure name="b92e" id="b92e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/9c9df906c0f929b7088ffb62d94c8507.js"></script></figure><h3 name="9faa" id="9faa" class="graf graf--h3 graf-after--figure">Real-World Example: The DAO</h3><p name="a076" id="a076" class="graf graf--p graf-after--h3"><a href="https://en.wikipedia.org/wiki/The_DAO_%28organization%29" data-href="https://en.wikipedia.org/wiki/The_DAO_(organization)" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">The DAO</a> (Decentralized Autonomous Organization) was one of the major hacks that occurred in the early development of Ethereum. At the time, the contract held over $150 million USD. Re-entrancy played a major role in the attack which ultimately lead to the hard-fork that created Ethereum Classic (ETC). For a good analysis of the DAO exploit, see <a href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" data-href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Phil Daian’s post</a>.</p><h3 name="adba" id="adba" class="graf graf--h3 graf-after--p">2. Arithmetic Over/Under Flows</h3><p name="cf24" id="cf24" class="graf graf--p graf-after--h3">The Ethereum Virtual Machine (EVM) specifies fixed-size data types for integers. This means that an integer variable, only has a certain range of numbers it can represent. A <code class="markup--code markup--p-code">uint8</code> for example, can only store numbers in the range [0,255]. Trying to store <code class="markup--code markup--p-code">256</code> into a <code class="markup--code markup--p-code">uint8</code> will result in <code class="markup--code markup--p-code">0</code>. If care is not taken, variables in Solidity can be exploited if user input is unchecked and calculations are performed which result in numbers that lie outside the range of the data type that stores them.</p><p name="d52e" id="d52e" class="graf graf--p graf-after--p">For further reading on arithmetic over/under flows, see <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" data-href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">How to Secure Your Smart Contracts</a>, <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow" data-href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethereum Smart Contract Best Practices</a> and <a href="https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/" data-href="https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethereum, Solidity and integer overflows: programming blockchains like 1970</a></p><h3 name="ea8d" id="ea8d" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="8190" id="8190" class="graf graf--p graf-after--h3">An over/under flow occurs when an operation is performed that requires a fixed size variable to store a number (or piece of data) that is outside the range of the variable’s data type.</p><p name="273f" id="273f" class="graf graf--p graf-after--p">For example, subtracting <code class="markup--code markup--p-code">1</code> from a <code class="markup--code markup--p-code">uint8</code> (unsigned integer of 8 bits, i.e. only positive) variable that stores <code class="markup--code markup--p-code">0</code> as it&#39;s value, will result in the number <code class="markup--code markup--p-code">255</code>. This is an underflow. We have assigned a number below the range of the <code class="markup--code markup--p-code">uint8</code>, the result <em class="markup--em markup--p-em">wraps around</em> and gives the largest number a <code class="markup--code markup--p-code">uint8</code> can store. Similarly, adding <code class="markup--code markup--p-code">2^8=256</code> to a <code class="markup--code markup--p-code">uint8</code> will leave the variable unchanged as we have wrapped around the entire length of the <code class="markup--code markup--p-code">uint</code> (for the mathematicians, this is similar to adding $2\pi$ to the angle of a trigonometric function, $\sin(x) = \sin(x+2\pi)$). Adding numbers larger than the data type&#39;s range is called an overflow. For clarity, adding <code class="markup--code markup--p-code">257</code> to a <code class="markup--code markup--p-code">uint8</code> that currently has a zero value will result in the number <code class="markup--code markup--p-code">1</code>. It&#39;s sometimes instructive to think of fixed type variables being cyclic, where we start again from zero if we add numbers above the largest possible stored number, and vice-versa for zero (where we start counting down from the largest number the more we subtract from 0).</p><p name="342e" id="342e" class="graf graf--p graf-after--p">These kinds of vulnerabilities allow attackers to misuse code and create unexpected logic flows. For example, consider the time locking contract below.</p><h4 name="b243" id="b243" class="graf graf--h4 graf-after--p">TimeLock.sol</h4><figure name="1893" id="1893" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/4ee0b3213d13cb9a28ad73c66eda495a.js"></script></figure><p name="f3ac" id="f3ac" class="graf graf--p graf-after--figure">This contract is designed to act like a time vault, where users can deposit ether into the contract and it will be locked there for at least a week. The user may extend the time longer than 1 week if they choose, but once deposited, the user can be sure their ether is locked in safely for at least a week. Or can they?…</p><p name="9b70" id="9b70" class="graf graf--p graf-after--p">In the event a user is forced to hand over their private key (think hostage situation) a contract such as this may be handy to ensure ether is unobtainable in short periods of time. If a user had locked in <code class="markup--code markup--p-code">100 ether</code> in this contract and handed their keys over to an attacker, an attacker could use an overflow to receive the ether, regardless of the <code class="markup--code markup--p-code">lockTime</code>.</p><p name="8e7e" id="8e7e" class="graf graf--p graf-after--p">The attacker could determine the current <code class="markup--code markup--p-code">lockTime</code> for the address they now hold the key for (its a public variable). Let&#39;s call this <code class="markup--code markup--p-code">userLockTime</code>. They could then call the <code class="markup--code markup--p-code">increaseLockTime</code> function and pass as an argument the number <code class="markup--code markup--p-code">2^256 - userLockTime</code>. This number would be added to the current <code class="markup--code markup--p-code">userLockTime</code> and cause an overflow, resetting <code class="markup--code markup--p-code">lockTime[msg.sender]</code> to <code class="markup--code markup--p-code">0</code>. The attacker could then simply call the <code class="markup--code markup--p-code">withdraw</code> function to obtain their reward.</p><p name="fedc" id="fedc" class="graf graf--p graf-after--p">Let’s look at another example, this one from the <a href="https://github.com/OpenZeppelin/ethernaut" data-href="https://github.com/OpenZeppelin/ethernaut" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethernaut Challanges</a>.</p><p name="7867" id="7867" class="graf graf--p graf-after--p">SPOILER ALERT: <em class="markup--em markup--p-em">If you’ve not yet done the Ethernaut challenges, this gives a solution to one of the levels</em>.</p><figure name="5dff" id="5dff" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/274351d5ac82ddfd99e0048ca6667871.js"></script></figure><p name="d504" id="d504" class="graf graf--p graf-after--figure">This is a simple token contract which employs a <code class="markup--code markup--p-code">transfer()</code> function, allowing participants to move their tokens around. Can you see the error in this contract?</p><p name="0b7c" id="0b7c" class="graf graf--p graf-after--p">The flaw comes in the <code class="markup--code markup--p-code">transfer()</code> function. The require statement on line [13] can be bypassed using an underflow. Consider a user that has no balance. They could call the <code class="markup--code markup--p-code">transfer()</code> function with any non-zero <code class="markup--code markup--p-code">_value</code> and pass the require statement on line [13]. This is because <code class="markup--code markup--p-code">balances[msg.sender]</code> is zero (and a <code class="markup--code markup--p-code">uint256</code>) so subtracting any positive amount (excluding <code class="markup--code markup--p-code">2^256</code>) will result in a positive number due to the underflow we described above. This is also true for line [14], where our balance will be credited with a positive number. Thus, in this example, we have achieved free tokens due to an underflow vulnerability.</p><h3 name="7cf1" id="7cf1" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="129b" id="129b" class="graf graf--p graf-after--h3">The (currently) conventional technique to guard against under/overflow vulnerabilities is to use or build mathematical libraries which replace the standard math operators; addition, subtraction and multiplication (division is excluded as it doesn’t cause over/under flows and the EVM throws on division by 0).</p><p name="b0ed" id="b0ed" class="graf graf--p graf-after--p"><a href="https://github.com/OpenZeppelin/zeppelin-solidity" data-href="https://github.com/OpenZeppelin/zeppelin-solidity" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">OppenZepplin</a> have done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community. In particular, their <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" data-href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Safe Math Library</a> is a reference or library to use to avoid under/over flow vulnerabilities.</p><p name="3c1e" id="3c1e" class="graf graf--p graf-after--p">To demonstrate how these libraries are used in Solidity, let us correct the <code class="markup--code markup--p-code">TimeLock</code> contract, using Open Zepplin&#39;s <code class="markup--code markup--p-code">SafeMath</code>library. The over flow-free contract would become:</p><figure name="ff11" id="ff11" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/2919d46a194bb086d2cc46176b7d8f32.js"></script></figure><p name="4ba7" id="4ba7" class="graf graf--p graf-after--figure">Notice that all standard math operations have been replaced by the those defined in the <code class="markup--code markup--p-code">SafeMath</code> library. The <code class="markup--code markup--p-code">TimeLock</code>contract no longer performs any operation which is capable of doing an under/over flow.</p><h3 name="2950" id="2950" class="graf graf--h3 graf-after--p">Real-World Examples: PoWHC and Batch Transfer Overflow (<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-10299" data-href="https://nvd.nist.gov/vuln/detail/CVE-2018-10299" class="markup--anchor markup--h3-anchor" rel="nofollow noopener" target="_blank">CVE-2018–10299</a>)</h3><p name="a3ae" id="a3ae" class="graf graf--p graf-after--h3">A 4chan group decided it was a great idea to build a ponzi scheme on Ethereum, written in Solidity. They called it the Proof of Weak Hands Coin (PoWHC). Unfortunately it seems that the author(s) of the contract hadn’t seen over/under flows before and consequently, 866 ether was liberated from its contract. A good overview of how the underflow occurs (which is not too dissimilar to the Ethernaut challenge above) is given in <a href="https://blog.goodaudience.com/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530" data-href="https://blog.goodaudience.com/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Eric Banisadar’s post</a>.</p><p name="4950" id="4950" class="graf graf--p graf-after--p">Some developers also implemented a <code class="markup--code markup--p-code">batchTransfer()</code> function into some <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a> token contracts. The implementation contained an overflow. <a href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536" data-href="https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">This post</a> explains it, however I think the title is misleading, in that it has nothing to do with the ERC20 standard, rather some ERC20 token contracts have a vulnerable <code class="markup--code markup--p-code">batchTransfer()</code> function implemented.</p><h3 name="77f5" id="77f5" class="graf graf--h3 graf-after--p">3. Unexpected Ether</h3><p name="f494" id="f494" class="graf graf--p graf-after--h3">Typically when ether is sent to a contract, it must execute either the fallback function, or another function described in the contract. There are two exceptions to this, where ether can exist in a contract without having executed any code. Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is forcibly sent to a contract.</p><p name="e095" id="e095" class="graf graf--p graf-after--p">For further reading on this, see <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834" data-href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">How to Secure Your Smart Contracts: 6</a> and <a href="http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html" data-href="http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity security patterns — forcing ether to a contract </a>.</p><h3 name="74cb" id="74cb" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="af2a" id="af2a" class="graf graf--p graf-after--h3">A common defensive programming technique that is useful in enforcing correct state transitions or validating operations is <em class="markup--em markup--p-em">invariant-checking</em>. This technique involves defining a set of invariants (metrics or parameters that should not change) and checking these invariants remain unchanged after a single (or many) operation(s). This is typically good design, provided the invariants being checked are in fact invariants. One example of an invariant is the <code class="markup--code markup--p-code">totalSupply</code> of a fixed issuance <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a>token. As no functions should modify this invariant, one could add a check to the <code class="markup--code markup--p-code">transfer()</code> function that ensures the <code class="markup--code markup--p-code">totalSupply</code> remains unmodified to ensure the function is working as expected.</p><p name="ea1b" id="ea1b" class="graf graf--p graf-after--p">There is one apparent <em class="markup--em markup--p-em">“invariant”</em>, in particular, that may tempt developers to use, but can in fact be manipulated by external users, regardless of the rules put in place in the smart contract. This is the current ether stored in the contract. Often, when developers first learn Solidity, they have the misconception that a contract can only accept or obtain ether via payable functions. This misconception can lead to contracts that have false assumptions about the ether balance within them which can lead to a range of vulnerabilities. The smoking gun for this vulnerability is the (incorrect) use of <code class="markup--code markup--p-code">this.balance</code>. As we will see, incorrect uses of <code class="markup--code markup--p-code">this.balance</code> can lead to serious vulnerabilities of this type.</p><p name="c858" id="c858" class="graf graf--p graf-after--p">There are two ways in which ether can (forcibly) be sent to a contract without using a <code class="markup--code markup--p-code">payable</code> function or executing any code on the contract. These are listed below.</p><h4 name="c212" id="c212" class="graf graf--h4 graf-after--p">Self Destruct / Suicide</h4><p name="7580" id="7580" class="graf graf--p graf-after--h4">Any contract is able to implement the <code class="markup--code markup--p-code"><a href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct" data-href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">selfdestruct(address)</a></code> function, which removes all bytecode from the contract address and sends all ether stored there to the parameter-specified address. If this specified address is also a contract, no functions (including the fallback) get called. Therefore, the <code class="markup--code markup--p-code">selfdestruct()</code> function can be used to forcibly send ether to any contract regardless of any code that may exist in the contract. This is inclusive of contracts without any payable functions. This means, any attacker can create a contract with a <code class="markup--code markup--p-code">selfdestruct()</code> function, send ether to it, call <code class="markup--code markup--p-code">selfdestruct(target)</code> and force ether to be sent to a <code class="markup--code markup--p-code">target</code> contract. Martin Swende has an excellent <a href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" data-href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">blog post</a> describing some quirks of the self-destruct opcode (Quirk #2) along with a description of how client nodes were checking incorrect invariants which could have lead to a rather catastrophic nuking of clients.</p><h4 name="6df9" id="6df9" class="graf graf--h4 graf-after--p">Pre-sent Ether</h4><p name="e088" id="e088" class="graf graf--p graf-after--h4">The second way a contract can obtain ether without using a <code class="markup--code markup--p-code">selfdestruct()</code> function or calling any payable functions is to pre-load the contract address with ether. Contract addresses are deterministic, in fact the address is calculated from the hash of the address creating the contract and the transaction nonce which creates the contract. i.e. of the form: <code class="markup--code markup--p-code">address = sha3(rlp.encode([account_address,transaction_nonce]))</code> (see <a href="https://hackernoon.com/hackpedia-16-solidity-hacks-vulnerabilities-their-fixes-and-real-world-examples-f3210eba5148#ad85" data-href="https://hackernoon.com/hackpedia-16-solidity-hacks-vulnerabilities-their-fixes-and-real-world-examples-f3210eba5148#ad85" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Keyless Ether</a> for some fun use cases of this). This means, anyone can calculate what a contract address will be before it is created and thus send ether to that address. When the contract does get created it will have a non-zero ether balance.</p><p name="a6c4" id="a6c4" class="graf graf--p graf-after--p">Let’s explore some pitfalls that can arise given the above knowledge.</p><p name="6763" id="6763" class="graf graf--p graf-after--p">Consider the overly-simple contract,</p><h4 name="945b" id="945b" class="graf graf--h4 graf-after--p">EtherGame.sol</h4><figure name="7736" id="7736" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/415a17c709d804a4d351485cd1b7c981.js"></script></figure><p name="5929" id="5929" class="graf graf--p graf-after--figure">This contract represents a simple game (which would naturally invoke <a href="https://github.com/sigp/solidity-security-blog#race-conditions" data-href="https://github.com/sigp/solidity-security-blog#race-conditions" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">race-conditions</a>) whereby players send <code class="markup--code markup--p-code">0.5 ether</code>quanta to the contract in hope to be the player that reaches one of three milestones first. Milestone&#39;s are denominated in ether. The first to reach the milestone may claim a portion of the ether when the game has ended. The game ends when the final milestone (<code class="markup--code markup--p-code">10 ether</code>) is reached and users can claim their rewards.</p><p name="d018" id="d018" class="graf graf--p graf-after--p">The issues with the <code class="markup--code markup--p-code">EtherGame</code> contract come from the poor use of <code class="markup--code markup--p-code">this.balance</code> in both lines [14] (and by association [16]) and [32]. A mischievous attacker could forcibly send a small amount of ether, let&#39;s say <code class="markup--code markup--p-code">0.1 ether</code> via the <code class="markup--code markup--p-code">selfdestruct()</code>function (discussed above) to prevent any future players from reaching a milestone. As all legitimate players can only send <code class="markup--code markup--p-code">0.5 ether</code> increments, <code class="markup--code markup--p-code">this.balance</code> would no longer be half integer numbers, as it would also have the <code class="markup--code markup--p-code">0.1 ether</code>contribution. This prevents all the if conditions on lines [18], [21] and [24] from being true.</p><p name="8cf7" id="8cf7" class="graf graf--p graf-after--p">Even worse, a vengeful attacker who missed a milestone, could forcibly send <code class="markup--code markup--p-code">10 ether</code> (or an equivalent amount of ether that pushes the contract&#39;s balance above the <code class="markup--code markup--p-code">finalMileStone</code>) which would lock all rewards in the contract forever. This is because the <code class="markup--code markup--p-code">claimReward()</code> function will always revert, due to the require on line [32] (i.e. <code class="markup--code markup--p-code">this.balance</code> is greater than <code class="markup--code markup--p-code">finalMileStone</code>).</p><h3 name="e8d7" id="e8d7" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="1649" id="1649" class="graf graf--p graf-after--h3">This vulnerability typically arises from the misuse of <code class="markup--code markup--p-code">this.balance</code>. Contract logic, when possible, should avoid being dependent on exact values of the balance of the contract because it can be artificially manipulated. If applying logic based on <code class="markup--code markup--p-code">this.balance</code>, ensure to account for unexpected balances.</p><p name="467a" id="467a" class="graf graf--p graf-after--p">If exact values of deposited ether are required, a self-defined variable should be used that gets incremented in payable functions, to safely track the deposited ether. This variable will not be influenced by the forced ether sent via a <code class="markup--code markup--p-code">selfdestruct()</code> call.</p><p name="b75b" id="b75b" class="graf graf--p graf-after--p">With this in mind, a corrected version of the <code class="markup--code markup--p-code">EtherGame</code> contract could look like:</p><figure name="d444" id="d444" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/4edb6734ee9d1c214af21c6ef833f3e0.js"></script></figure><p name="1f3f" id="1f3f" class="graf graf--p graf-after--figure">Here, we have just created a new variable, <code class="markup--code markup--p-code">depositedEther</code> which keeps track of the known ether deposited, and it is this variable to which we perform our requirements and tests. Notice, that we no longer have any reference to <code class="markup--code markup--p-code">this.balance</code>.</p><h3 name="58fb" id="58fb" class="graf graf--h3 graf-after--p">Real-World Example: Unknown</h3><p name="b692" id="b692" class="graf graf--p graf-after--h3">I’m yet to find and example of this that has been exploited in the wild. However, a few examples of exploitable contracts were given in the <a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/" data-href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Underhanded Solidity Contest</a>.</p><h3 name="1ac4" id="1ac4" class="graf graf--h3 graf-after--p">4. Delegatecall</h3><p name="7997" id="7997" class="graf graf--p graf-after--h3">The <code class="markup--code markup--p-code">CALL</code> and <code class="markup--code markup--p-code">DELEGATECALL</code> opcodes are useful in allowing Ethereum developers to modularise their code. Standard external message calls to contracts are handled by the <code class="markup--code markup--p-code">CALL</code> opcode whereby code is run in the context of the external contract/function. The <code class="markup--code markup--p-code">DELEGATECALL</code> opcode is identical to the standard message call, except that the code executed at the targeted address is run in the context of the calling contract along with the fact that <code class="markup--code markup--p-code">msg.sender</code> and <code class="markup--code markup--p-code">msg.value</code> remain unchanged. This feature enables the implementation of <em class="markup--em markup--p-em">libraries</em> whereby developers can create reusable code for future contracts.</p><p name="957b" id="957b" class="graf graf--p graf-after--p">Although the differences between these two opcodes are simple and intuitive, the use of <code class="markup--code markup--p-code">DELEGATECALL</code> can lead to unexpected code execution.</p><p name="2bfe" id="2bfe" class="graf graf--p graf-after--p">For further reading, see <a href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall" data-href="https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethereum Stack Exchange Question</a>, <a href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" data-href="http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs</a> and <a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" data-href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">How to Secure Your Smart Contracts: 6</a>.</p><h3 name="684f" id="684f" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="7344" id="7344" class="graf graf--p graf-after--h3">The context preserving nature of <code class="markup--code markup--p-code">DELEGATECALL</code> has proved that building vulnerability-free custom libraries is not as easy as one might think. The code in libraries themselves can be secure and vulnerability-free however when run in the context of another application new vulnerabilities can arise. Let&#39;s see a fairly complex example of this, using Fibonacci numbers.</p><p name="6ff9" id="6ff9" class="graf graf--p graf-after--p">Consider the following library which can generate the Fibonacci sequence and sequences of similar form.<code class="markup--code markup--p-code">FibonacciLib.sol</code> (This code was modified from <a href="https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol" data-href="https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">web3j</a>)</p><figure name="dcc7" id="dcc7" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/23023e60dd1f602c127ef867243b4ae5.js"></script></figure><p name="1d2d" id="1d2d" class="graf graf--p graf-after--figure">This library provides a function which can generate the <em class="markup--em markup--p-em">n</em>-th Fibonacci number in the sequence. It allows users to change the 0-th <code class="markup--code markup--p-code">start</code> number and calculate the <em class="markup--em markup--p-em">n</em>-th Fibonacci-like numbers in this new sequence.</p><p name="b2fd" id="b2fd" class="graf graf--p graf-after--p">Let’s now consider a contract that utilises this library.</p><h4 name="069b" id="069b" class="graf graf--h4 graf-after--p"><code class="markup--code markup--h4-code">FibonacciBalance.sol</code></h4><figure name="538e" id="538e" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/b8f734a09b48c4b3133ebf6c1875983d.js"></script></figure><p name="eec2" id="eec2" class="graf graf--p graf-after--figure">This contract allows a participant to withdraw ether from the contract, with the amount of ether being equal to the Fibonacci number corresponding to the participants withdrawal order; i.e., the first participant gets 1 ether, the second also gets 1, the third gets 2, the forth gets 3, the fifth 5 and so on (until the balance of the contract is less than the Fibonacci number being withdrawn).</p><p name="c1da" id="c1da" class="graf graf--p graf-after--p">There are a number of elements in this contract that may require some explanation. Firstly, there is an interesting-looking variable, <code class="markup--code markup--p-code">fibSig</code>. This holds the first 4 bytes of the Keccak (SHA-3) hash of the string &quot;fibonacci(uint256)&quot;. This is known as the <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" data-href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">function selector</a> and is put into <code class="markup--code markup--p-code">calldata</code> to specify which function of a smart contract will be called. It is used in the <code class="markup--code markup--p-code">delegatecall</code> function on line [21] to specify that we wish to run the <code class="markup--code markup--p-code">fibonacci(uint256)</code> function. The second argument in <code class="markup--code markup--p-code">delegatecall</code> is the parameter we are passing to the function. Secondly, we assume that the address for the <code class="markup--code markup--p-code">FibonacciLib</code>library is correctly referenced in the constructor (section <a href="https://github.com/sigp/solidity-security-blog#deployment" data-href="https://github.com/sigp/solidity-security-blog#deployment" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Deployment Attack Vectors</a> discuss some potential vulnerabilities relating to this kind if contract reference initialisation).</p><p name="5c55" id="5c55" class="graf graf--p graf-after--p">Can you spot any error(s) in this contract? If you put this into remix, fill it with ether and call <code class="markup--code markup--p-code">withdraw()</code>, it will likely revert.</p><p name="0811" id="0811" class="graf graf--p graf-after--p">You may have noticed that the state variable <code class="markup--code markup--p-code">start</code> is used in both the library and the main calling contract. In the library contract, <code class="markup--code markup--p-code">start</code> is used to specify the beginning of the Fibonacci sequence and is set to <code class="markup--code markup--p-code">0</code>, whereas it is set to <code class="markup--code markup--p-code">3</code> in the <code class="markup--code markup--p-code">FibonacciBalance</code> contract. You may also have noticed that the fallback function in the <code class="markup--code markup--p-code">FibonacciBalance</code> contract allows all calls to be passed to the library contract, which allows for the <code class="markup--code markup--p-code">setStart()</code> function of the library contract to be called also. Recalling that we preserve the state of the contract, it may seem that this function would allow you to change the state of the <code class="markup--code markup--p-code">start</code> variable in the local <code class="markup--code markup--p-code">FibonnacciBalance</code> contract. If so, this would allow one to withdraw more ether, as the resulting <code class="markup--code markup--p-code">calculatedFibNumber</code> is dependent on the <code class="markup--code markup--p-code">start</code> variable (as seen in the library contract). In actual fact, the <code class="markup--code markup--p-code">setStart()</code>function does not (and cannot) modify the <code class="markup--code markup--p-code">start</code> variable in the <code class="markup--code markup--p-code">FibonacciBalance</code> contract. The underlying vulnerability in this contract is significantly worse than just modifying the <code class="markup--code markup--p-code">start</code> variable.</p><p name="c9e3" id="c9e3" class="graf graf--p graf-after--p">Before discussing the actual issue, we take a quick detour to understanding how state variables (<code class="markup--code markup--p-code">storage</code> variables) actually get stored in contracts. State or <code class="markup--code markup--p-code">storage</code> variables (variables that persist over individual transactions) are placed into <code class="markup--code markup--p-code">slots</code>sequentially as they are introduced in the contract. (There are some complexities here, and I encourage the reader to read <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" data-href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Layout of State Variables in Storage</a> for a more thorough understanding).</p><p name="6174" id="6174" class="graf graf--p graf-after--p">As an example, let’s look at the library contract. It has two state variables, <code class="markup--code markup--p-code">start</code> and <code class="markup--code markup--p-code">calculatedFibNumber</code>. The first variable is <code class="markup--code markup--p-code">start</code>, as such it gets stored into the contract&#39;s storage at <code class="markup--code markup--p-code">slot[0]</code> (i.e. the first slot). The second variable, <code class="markup--code markup--p-code">calculatedFibNumber</code>, gets placed in the next available storage slot, <code class="markup--code markup--p-code">slot[1]</code>. If we look at the function <code class="markup--code markup--p-code">setStart()</code>, it takes an input and sets <code class="markup--code markup--p-code">start</code> to whatever the input was. This function is therefore setting <code class="markup--code markup--p-code">slot[0]</code> to whatever input we provide in the <code class="markup--code markup--p-code">setStart()</code> function. Similarly, the <code class="markup--code markup--p-code">setFibonacci()</code> function sets <code class="markup--code markup--p-code">calculatedFibNumber</code> to the result of <code class="markup--code markup--p-code">fibonacci(n)</code>. Again, this is simply setting storage <code class="markup--code markup--p-code">slot[1]</code> to the value of <code class="markup--code markup--p-code">fibonacci(n)</code>.</p><p name="ad6a" id="ad6a" class="graf graf--p graf-after--p">Now lets look at the <code class="markup--code markup--p-code">FibonacciBalance</code> contract. Storage <code class="markup--code markup--p-code">slot[0]</code> now corresponds to <code class="markup--code markup--p-code">fibonacciLibrary</code> address and <code class="markup--code markup--p-code">slot[1]</code> corresponds to <code class="markup--code markup--p-code">calculatedFibNumber</code>. It is here where the vulnerability appears. <code class="markup--code markup--p-code">delegatecall</code> preserves contract context. This means that code that is executed via <code class="markup--code markup--p-code">delegatecall</code> will act on the state (i.e. storage) of the calling contract.</p><p name="9ec5" id="9ec5" class="graf graf--p graf-after--p">Now notice that in <code class="markup--code markup--p-code">withdraw()</code> on line [21] we execute, <code class="markup--code markup--p-code">fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)</code>. This calls the <code class="markup--code markup--p-code">setFibonacci()</code> function, which as we discussed, modifies storage <code class="markup--code markup--p-code">slot[1]</code>, which in our current context is <code class="markup--code markup--p-code">calculatedFibNumber</code>. This is as expected (i.e. after execution, <code class="markup--code markup--p-code">calculatedFibNumber</code> gets adjusted). However, recall that the <code class="markup--code markup--p-code">start</code> variable in the <code class="markup--code markup--p-code">FibonacciLib</code> contract is located in storage <code class="markup--code markup--p-code">slot[0]</code>, which is the <code class="markup--code markup--p-code">fibonacciLibrary</code> address in the current contract. This means that the function <code class="markup--code markup--p-code">fibonacci()</code> will give an unexpected result. This is because it references <code class="markup--code markup--p-code">start</code> (<code class="markup--code markup--p-code">slot[0]</code>) which in the current calling context is the <code class="markup--code markup--p-code">fibonacciLibrary</code> address (which will often be quite large, when interpreted as a <code class="markup--code markup--p-code">uint</code>). Thus it is likely that the <code class="markup--code markup--p-code">withdraw()</code> function will revert as it will not contain <code class="markup--code markup--p-code">uint(fibonacciLibrary)</code> amount of ether, which is what <code class="markup--code markup--p-code">calcultedFibNumber</code> will return.</p><p name="81f1" id="81f1" class="graf graf--p graf-after--p">Even worse, the <code class="markup--code markup--p-code">FibonacciBalance</code> contract allows users to call all of the <code class="markup--code markup--p-code">fibonacciLibrary</code> functions via the fallback function on line [26]. As we discussed earlier, this includes the <code class="markup--code markup--p-code">setStart()</code> function. We discussed that this function allows anyone to modify or set storage <code class="markup--code markup--p-code">slot[0]</code>. In this case, storage <code class="markup--code markup--p-code">slot[0]</code> is the <code class="markup--code markup--p-code">fibonacciLibrary</code> address. Therefore, an attacker could create a malicious contract (an example of one is below), convert the address to a <code class="markup--code markup--p-code">uint</code> (this can be done in python easily using <code class="markup--code markup--p-code">int(&#39;&lt;address&gt;&#39;,16)</code>) and then call <code class="markup--code markup--p-code">setStart(&lt;attack_contract_address_as_uint&gt;)</code>. This will change <code class="markup--code markup--p-code">fibonacciLibrary</code> to the address of the attack contract. Then, whenever a user calls <code class="markup--code markup--p-code">withdraw()</code> or the fallback function, the malicious contract will run (which can steal the entire balance of the contract) because we&#39;ve modified the actual address for <code class="markup--code markup--p-code">fibonacciLibrary</code>. An example of such an attack contract would be,</p><figure name="65a8" id="65a8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/b47fe7868411361c3ef436c48adbc91b.js"></script></figure><p name="e1da" id="e1da" class="graf graf--p graf-after--figure">Notice that this attack contract modifies the <code class="markup--code markup--p-code">calculatedFibNumber</code> by changing storage <code class="markup--code markup--p-code">slot[1]</code>. In principle, an attacker could modify any other storage slots they choose to perform all kinds of attacks on this contract. I encourage all readers to put these contracts into <a href="https://remix.ethereum.org/" data-href="https://remix.ethereum.org/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Remix</a> and experiment with different attack contracts and state changes through these <code class="markup--code markup--p-code">delegatecall</code>functions.</p><p name="a968" id="a968" class="graf graf--p graf-after--p">It is also important to notice that when we say that <code class="markup--code markup--p-code">delegatecall</code> is state-preserving, we are not talking about the variable names of the contract, rather the actual storage slots to which those names point. As you can see from this example, a simple mistake, can lead to an attacker hijacking the entire contract and its ether.</p><h3 name="74ac" id="74ac" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="7586" id="7586" class="graf graf--p graf-after--h3">Solidity provides the <code class="markup--code markup--p-code">library</code> keyword for implementing library contracts (see the <a href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries" data-href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs</a> for further details). This ensures the library contract is stateless and non-self-destructable. Forcing libraries to be stateless mitigates the complexities of storage context demonstrated in this section. Stateless libraries also prevent attacks whereby attackers modify the state of the library directly in order to effect the contracts that depend on the library&#39;s code. As a general rule of thumb, when using <code class="markup--code markup--p-code">DELEGATECALL</code> pay careful attention to the possible calling context of both the library contract and the calling contract, and whenever possible, build state-less libraries.</p><h3 name="a683" id="a683" class="graf graf--h3 graf-after--p">Real-World Example: Parity Multisig Wallet (Second Hack)</h3><p name="058a" id="058a" class="graf graf--p graf-after--h3">The Second Parity Multisig Wallet hack is an example of how the context of well-written library code can be exploited if run in its non-intended context. There are a number of good explanations of this hack, such as this overview: <a href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838" data-href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">Parity MultiSig Hacked. Again</a> by Anthony Akentiev, this <a href="https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130" data-href="https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">stack exchange question</a> and <a href="http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/" data-href="http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">An In-Depth Look at the Parity Multisig Bug</a>.</p><p name="a342" id="a342" class="graf graf--p graf-after--p">To add to these references, let’s explore the contracts that were exploited. The library and wallet contract can be found on the parity github <a href="https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol" data-href="https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><p name="4d5e" id="4d5e" class="graf graf--p graf-after--p">Let’s look at the relevant aspects of this contract. There are two contracts of interest contained here, the library contract and the wallet contract.</p><p name="c9d3" id="c9d3" class="graf graf--p graf-after--p">The library contract,</p><figure name="86f0" id="86f0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/712915bad162a173f738f0e7c15397d5.js"></script></figure><p name="d715" id="d715" class="graf graf--p graf-after--figure">and the wallet contract,</p><figure name="2c10" id="2c10" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/6a1133562533d6acbc540fd6417943eb.js"></script></figure><p name="c116" id="c116" class="graf graf--p graf-after--figure">Notice that the <code class="markup--code markup--p-code">Wallet</code> contract essentially passes all calls to the <code class="markup--code markup--p-code">WalletLibrary</code> contract via a delegate call. The constant <code class="markup--code markup--p-code">_walletLibrary</code> address in this code snippet acts as a placeholder for the actually deployed <code class="markup--code markup--p-code">WalletLibrary</code> contract (which was at <code class="markup--code markup--p-code">0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4</code>).</p><p name="41cf" id="41cf" class="graf graf--p graf-after--p">The intended operation of these contracts was to have a simple low-cost deployable <code class="markup--code markup--p-code">Wallet</code> contract whose code base and main functionality was in the <code class="markup--code markup--p-code">WalletLibrary</code> contract. Unfortunately, the <code class="markup--code markup--p-code">WalletLibrary</code> contract is itself a contract and maintains it&#39;s own state. Can you see why this might be an issue?</p><p name="ab52" id="ab52" class="graf graf--p graf-after--p">It is possible to send calls to the <code class="markup--code markup--p-code">WalletLibrary</code> contract itself. Specifically, the <code class="markup--code markup--p-code">WalletLibrary</code> contract could be initialised, and become owned. A user did this, by calling <code class="markup--code markup--p-code">initWallet()</code> function on the <code class="markup--code markup--p-code">WalletLibrary</code> contract, becoming an owner of the library contract. The same user, subsequently called the <code class="markup--code markup--p-code">kill()</code> function. Because the user was an owner of the Library contract, the modifier passed and the library contract suicided. As all <code class="markup--code markup--p-code">Wallet</code> contracts in existence refer to this library contract and contain no method to change this reference, all of their functionality, including the ability to withdraw ether is lost along with the <code class="markup--code markup--p-code">WalletLibrary</code> contract. More directly, all ether in all parity multi-sig wallets of this type instantly become lost or permanently unrecoverable.</p><h3 name="c673" id="c673" class="graf graf--h3 graf-after--p">5. Default Visibilities</h3><p name="485d" id="485d" class="graf graf--p graf-after--h3">Functions in Solidity have visibility specifiers which dictate how functions are allowed to be called. The visibility determines whether a function can be called externally by users, by other derived contracts, only internally or only externally. There are four visibility specifiers, which are described in detail in the <a href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters" data-href="http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs</a>. Functions default to <code class="markup--code markup--p-code">public</code> allowing users to call them externally. Incorrect use of visibility specifiers can lead to some devestating vulernabilities in smart contracts as will be discussed in this section.</p><h3 name="020d" id="020d" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="6528" id="6528" class="graf graf--p graf-after--h3">The default visibility for functions is <code class="markup--code markup--p-code">public</code>. Therefore functions that do not specify any visibility will be callable by external users. The issue comes when developers mistakenly ignore visibility specifiers on functions which should be private (or only callable within the contract itself).</p><p name="2b16" id="2b16" class="graf graf--p graf-after--p">Lets quickly explore a trivial example.</p><figure name="d5cd" id="d5cd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/21cc35d8a48d7768ab6acaff28b5a445.js"></script></figure><p name="120c" id="120c" class="graf graf--p graf-after--figure">This simple contract is designed to act as an address guessing bounty game. To win the balance of the contract, a user must generate an Ethereum address whose last 8 hex characters are 0. Once obtained, they can call the <code class="markup--code markup--p-code">WithdrawWinnings()</code>function to obtain their bounty.</p><p name="fab9" id="fab9" class="graf graf--p graf-after--p">Unfortunately, the visibility of the functions have not been specified. In particular, the <code class="markup--code markup--p-code">_sendWinnings()</code> function is <code class="markup--code markup--p-code">public</code>and thus any address can call this function to steal the bounty.</p><h3 name="7fce" id="7fce" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="d1dd" id="d1dd" class="graf graf--p graf-after--h3">It is good practice to always specify the visibility of all functions in a contract, even if they are intentionally <code class="markup--code markup--p-code">public</code>. Recent versions of Solidity will now show warnings during compilation for functions that have no explicit visibility set, to help encourage this practice.</p><h3 name="d623" id="d623" class="graf graf--h3 graf-after--p">Real-World Example: Parity MultiSig Wallet (First Hack)</h3><p name="8025" id="8025" class="graf graf--p graf-after--h3">In the first Parity multi-sig hack, about $31M worth of Ether was stolen from primarily three wallets. A good recap of exactly how this was done is given by Haseeb Qureshi in <a href="https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce" data-href="https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">this post</a>.</p><p name="25ab" id="25ab" class="graf graf--p graf-after--p">Essentially, the multi-sig wallet (which can be found <a href="https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol" data-href="https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>) is constructed from a base <code class="markup--code markup--p-code">Wallet</code> contract which calls a library contract containing the core functionality (as was described in <a href="https://github.com/sigp/solidity-security-blog#dc-example" data-href="https://github.com/sigp/solidity-security-blog#dc-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Real-World Example: Parity Multisig (Second Hack)</a>). The library contract contains the code to initialise the wallet as can be seen from the following snippet</p><figure name="0b18" id="0b18" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/df910a5b7fc0d985e73231e50c00259d.js"></script></figure><p name="5b80" id="5b80" class="graf graf--p graf-after--figure">Notice that neither of the functions have explicitly specified a visibility. Both functions default to <code class="markup--code markup--p-code">public</code>. The <code class="markup--code markup--p-code">initWallet()</code>function is called in the wallets constructor and sets the owners for the multi-sig wallet as can be seen in the <code class="markup--code markup--p-code">initMultiowned()</code> function. Because these functions were accidentally left <code class="markup--code markup--p-code">public</code>, an attacker was able to call these functions on deployed contracts, resetting the ownership to the attackers address. Being the owner, the attacker then drained the wallets of all their ether, to the tune of $31M.</p><h3 name="d597" id="d597" class="graf graf--h3 graf-after--p">6. Entropy Illusion</h3><p name="faf2" id="faf2" class="graf graf--p graf-after--h3">All transactions on the Ethereum blockchain are deterministic state transition operations. Meaning that every transaction modifies the global state of the Ethereum ecosystem and it does so in a calculable way with no uncertainty. This ultimately means that inside the blockchain ecosystem there is no source of entropy or randomness. There is no <code class="markup--code markup--p-code">rand()</code> function in Solidity. Achieving decentralised entropy (randomness) is a well established problem and many ideas have been proposed to address this (see for example, <a href="https://github.com/randao/randao" data-href="https://github.com/randao/randao" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RandDAO</a> or using a chain of Hashes as described by Vitalik in this <a href="https://vitalik.ca/files/randomness.html" data-href="https://vitalik.ca/files/randomness.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">post</a>).</p><h3 name="64c2" id="64c2" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="e670" id="e670" class="graf graf--p graf-after--h3">Some of the first contracts built on the Ethereum platform were based around gambling. Fundamentally, gambling requires uncertainty (something to bet on), which makes building a gambling system on the blockchain (a deterministic system) rather difficult. It is clear that the uncertainty must come from a source external to the blockchain. This is possible for bets amongst peers (see for example the <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" data-href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">commit-reveal technique</a>), however, it is significantly more difficult if you want to implement a contract to act as <em class="markup--em markup--p-em">the house</em> (like in blackjack our roulette). A common pitfall is to use future block variables, such as hashes, timestamps, blocknumber or gas limit. The issue with these are that they are controlled by the miner who mines the block and as such are not truly random. Consider, for example, a roulette smart contract with logic that returns a black number if the next block hash ends in an even number. A miner (or miner pool) could bet \$1M on black. If they solve the next block and find the hash ends in an odd number, they would happily not publish their block and mine another until they find a solution with the block hash being an even number (assuming the block reward and fees are less than $1M). Using past or present variables can be even more devastating as Martin Swende demonstrates in his excellent <a href="http://martin.swende.se/blog/Breaking_the_house.html" data-href="http://martin.swende.se/blog/Breaking_the_house.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">blog post</a>. Furthermore, using solely block variables mean that the pseudo-random number will be the same for all transactions in a block, so an attacker can multiply their wins by doing many transactions within a block (should there be a maximum bet).</p><h3 name="5672" id="5672" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="66c0" id="66c0" class="graf graf--p graf-after--h3">The source of entropy (randomness) must be external to the blockchain. This can be done amongst peers with systems such as <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" data-href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">commit-reveal</a>, or via changing the trust model to a group of participants (such as in <a href="https://github.com/randao/randao" data-href="https://github.com/randao/randao" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RandDAO</a>). This can also be done via a centralised entity, which acts as a randomness oracle. Block variables (in general, there are some exceptions) should not be used to source entropy as they can be manipulated by miners.</p><h3 name="5763" id="5763" class="graf graf--h3 graf-after--p">Real-World Example: PRNG Contracts</h3><p name="eb80" id="eb80" class="graf graf--p graf-after--h3">Arseny Reutov wrote a <a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" data-href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">blog post</a> after he analysed 3649 live smart contracts which were using some sort of pseudo random number generator (PRNG) and found 43 contracts which could be exploited. This post discusses the pitfalls of using block variables as entropy in further detail.</p><h3 name="33b9" id="33b9" class="graf graf--h3 graf-after--p">7. External Contract Referencing</h3><p name="3a5f" id="3a5f" class="graf graf--p graf-after--h3">One of the benefits of Ethereum <em class="markup--em markup--p-em">global computer</em> is the ability to re-use code and interact with contracts already deployed on the network. As a result, a large number of contracts reference external contracts and in general operation use external message calls to interact with these contracts. These external message calls can mask malicious actors intentions in some non-obvious ways, which we will discuss.</p><h3 name="df15" id="df15" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="586b" id="586b" class="graf graf--p graf-after--h3">In Solidity, any address can be cast as a contract regardless of whether the code at the address represents the contract type being cast. This can be deceiving, especially when the author of the contract is trying to hide malicious code. Let us illustrate this with an example:</p><p name="96c4" id="96c4" class="graf graf--p graf-after--p">Consider a piece of code which rudimentarily implements the <a href="https://github.com/sigp/solidity-security-blog/blob/master/www.wikipedia.com/rot13" data-href="https://github.com/sigp/solidity-security-blog/blob/master/www.wikipedia.com/rot13" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Rot13</a> cipher.</p><h4 name="025d" id="025d" class="graf graf--h4 graf-after--p"><code class="markup--code markup--h4-code">Rot13Encryption.sol</code></h4><figure name="ba4c" id="ba4c" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/03eb48547587196903fe707a53673580.js"></script></figure><p name="b4a1" id="b4a1" class="graf graf--p graf-after--figure">This code simply takes a string (letters a-z, without validation) and encrypts it by shifting each character 13 places to the right (wrapping around ‘z’); i.e. ‘a’ shifts to ’n’ and ‘x’ shifts to ‘k’. The assembly in here is not important, so don’t worry if it doesn’t make any sense at this stage.</p><p name="b959" id="b959" class="graf graf--p graf-after--p">Consider the following contract which uses this code for its encryption</p><figure name="ea8f" id="ea8f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/e7175d9a65216bb3286942c3ba3b5788.js"></script></figure><p name="abd8" id="abd8" class="graf graf--p graf-after--figure">The issue with this contract is that the <code class="markup--code markup--p-code">encryptionLibrary</code> address is not public or constant. Thus the deployer of the contract could have given an address in the constructor which points to this contract:</p><figure name="a017" id="a017" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/6cc6cfcfed3402e6717aa52bc811e610.js"></script></figure><p name="cde2" id="cde2" class="graf graf--p graf-after--figure">which implements the rot26 cipher (shifts each character by 26 places, get it? :p). Again, thre is no need to understand the assembly in this contract. The deployer could have also linked the following contract:</p><figure name="da8f" id="da8f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/7eb0708a26dd89302a4d4b7079822fb5.js"></script></figure><p name="02f1" id="02f1" class="graf graf--p graf-after--figure">If the address of either of these contracts were given in the constructor, the <code class="markup--code markup--p-code">encryptPrivateData()</code> function would simply produce an event which prints the unencrypted private data. Although in this example a library-like contract was set in the constructor, it is often the case that a privileged user (such as an <code class="markup--code markup--p-code">owner</code>) can change library contract addresses. If a linked contract doesn&#39;t contain the function being called, the fallback function will execute. For example, with the line <code class="markup--code markup--p-code">encryptionLibrary.rot13Encrypt()</code>, if the contract specified by <code class="markup--code markup--p-code">encryptionLibrary</code> was:</p><figure name="2b4f" id="2b4f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/80b9339c7cc9bf6bb332c175ec9444e1.js"></script></figure><p name="9393" id="9393" class="graf graf--p graf-after--figure">then an event with the text “Here” would be emitted. Thus if users can alter contract libraries, they can in principle get users to unknowingly run arbitrary code.</p><p name="c762" id="c762" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Note: Don’t use encryption contracts such as these, as the input parameters to smart contracts are visible on the blockchain. Also the Rot cipher is not a recommended encryption technique :p</em></p><h3 name="f673" id="f673" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="fecd" id="fecd" class="graf graf--p graf-after--h3">As demonstrated above, vulnerability free contracts can (in some cases) be deployed in such a way that they behave maliciously. An auditor could publicly verify a contract and have it’s owner deploy it in a malicious way, resulting in a publicly audited contract which has vulnerabilities or malicious intent.</p><p name="e3ca" id="e3ca" class="graf graf--p graf-after--p">There are a number of techniques which prevent these scenarios.</p><p name="d2cd" id="d2cd" class="graf graf--p graf-after--p">One technique, is to use the <code class="markup--code markup--p-code">new</code> keyword to create contracts. In the example above, the constructor could be written like:</p><pre name="4896" id="4896" class="graf graf--pre graf-after--p">constructor() {<br>        encryptionLibrary = new Rot13Encryption();<br>    }</pre><p name="f8ac" id="f8ac" class="graf graf--p graf-after--pre">This way an instance of the referenced contract is created at deployment time and the deployer cannot replace the <code class="markup--code markup--p-code">Rot13Encryption</code> contract with anything else without modifying the smart contract.</p><p name="88bf" id="88bf" class="graf graf--p graf-after--p">Another solution is to hard code any external contract addresses if they are known.</p><p name="ca09" id="ca09" class="graf graf--p graf-after--p">In general, code that calls external contracts should always be looked at carefully. As a developer, when defining external contracts, it can be a good idea to make the contract addresses public (which is not the case in the honey-pot example) to allow users to easily examine which code is being referenced by the contract. Conversely, if a contract has a private variable contract address it can be a sign of someone behaving maliciously (as shown in the real-world example). If a privileged (or any) user is capable of changing a contract address which is used to call external functions, it can be important (in a decentralised system context) to implement a time-lock or voting mechanism to allow users to see which code is being changed or to give participants a chance to opt in/out with the new contract address.</p><h3 name="50f2" id="50f2" class="graf graf--h3 graf-after--p">Real-World Example: Re-Entrancy Honey Pot</h3><p name="0915" id="0915" class="graf graf--p graf-after--h3">A number of recent honey pots have been released on the main net. These contracts try to outsmart Ethereum hackers who try to exploit the contracts, but who in turn end up getting ether lost to the contract they expect to exploit. One example employs the above attack by replacing an expected contract with a malicious one in the constructor. The code can be found <a href="https://etherscan.io/address/0x95d34980095380851902ccd9a1fb4c813c2cb639#code" data-href="https://etherscan.io/address/0x95d34980095380851902ccd9a1fb4c813c2cb639#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>:</p><figure name="f889" id="f889" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/bb7d843f84dae36968196f3a9594b71b.js"></script></figure><p name="a759" id="a759" class="graf graf--p graf-after--figure">This <a href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/" data-href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">post</a> by one reddit user explains how they lost 1 ether to this contract trying to exploit the re-entrancy bug they expected to be present in the contract.</p><h3 name="a503" id="a503" class="graf graf--h3 graf-after--p">8. Short Address/Parameter Attack</h3><p name="39b4" id="39b4" class="graf graf--p graf-after--h3">This attack is not specifically performed on Solidity contracts themselves but on third party applications that may interact them. I add this attack for completeness and to be aware of how parameters can be manipulated in contracts.</p><p name="5d8b" id="5d8b" class="graf graf--p graf-after--p">For further reading, see <a href="https://vessenes.com/the-erc20-short-address-attack-explained/" data-href="https://vessenes.com/the-erc20-short-address-attack-explained/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">The ERC20 Short Address Attack Explained</a>, <a href="https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b" data-href="https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">ICO Smart contract Vulnerability: Short Address Attack</a>or this <a href="https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/" data-href="https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">reddit post</a>.</p><h3 name="6160" id="6160" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="bf9c" id="bf9c" class="graf graf--p graf-after--h3">When passing parameters to a smart contract, the parameters are encoded according to the <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html" data-href="https://solidity.readthedocs.io/en/latest/abi-spec.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">ABI specification</a>. It is possible to send encoded parameters that are shorter than the expected parameter length (for example, sending an address that is only 38 hex chars (19 bytes) instead of the standard 40 hex chars (20 bytes)). In such a scenario, the EVM will pad 0’s to the end of the encoded parameters to make up the expected length.</p><p name="1044" id="1044" class="graf graf--p graf-after--p">This becomes an issue when third party applications do not validate inputs. The clearest example is an exchange which doesn’t verify the address of an <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a> token when a user requests a withdrawal. This example is covered in more detail in Peter Venesses’ post, <a href="http://vessenes.com/the-erc20-short-address-attack-explained/" data-href="http://vessenes.com/the-erc20-short-address-attack-explained/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">The ERC20 Short Address Attack Explained</a> mentioned above.</p><p name="fc15" id="fc15" class="graf graf--p graf-after--p">Consider, the standard <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a> transfer function interface, noting the order of the parameters,</p><pre name="05a8" id="05a8" class="graf graf--pre graf-after--p">function transfer(address to, uint tokens) public returns (bool success);</pre><p name="fdbb" id="fdbb" class="graf graf--p graf-after--pre">Now consider, an exchange, holding a large amount of a token (let’s say <code class="markup--code markup--p-code">REP</code>) and a user wishes to withdraw their share of 100 tokens. The user would submit their address, <code class="markup--code markup--p-code">0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead</code> and the number of tokens, <code class="markup--code markup--p-code">100</code>. The exchange would encode these parameters in the order specified by the <code class="markup--code markup--p-code">transfer()</code> function, i.e. <code class="markup--code markup--p-code">address</code> then <code class="markup--code markup--p-code">tokens</code>. The encoded result would be <code class="markup--code markup--p-code">a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000</code>. The first four bytes (<code class="markup--code markup--p-code">a9059cbb</code>) are the <code class="markup--code markup--p-code">transfer()</code> <a href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" data-href="https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">function signature/selector</a>, the second 32 bytes are the address, followed by the final 32 bytes which represent the <code class="markup--code markup--p-code">uint256</code> number of tokens. Notice that the hex <code class="markup--code markup--p-code">56bc75e2d63100000</code> at the end corresponds to 100 tokens (with 18 decimal places, as specified by the <code class="markup--code markup--p-code">REP</code> token contract).</p><p name="634d" id="634d" class="graf graf--p graf-after--p">Ok, so now lets look at what happens if we were to send an address that was missing 1 byte (2 hex digits). Specifically, let’s say an attacker sends <code class="markup--code markup--p-code">0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde</code>as an address (missing the last two digits) and the same<code class="markup--code markup--p-code">100</code> tokens to withdraw. If the exchange doesn&#39;t validate this input, it would get encoded as <code class="markup--code markup--p-code">a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000</code>. The difference is subtle. Note that <code class="markup--code markup--p-code">00</code> has been padded to the end of the encoding, to make up for the short address that was sent. When this gets sent to the smart contract, the <code class="markup--code markup--p-code">address</code>parameters will read as <code class="markup--code markup--p-code">0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00</code> and the value will be read as <code class="markup--code markup--p-code">56bc75e2d6310000000</code> (notice the two extra <code class="markup--code markup--p-code">0</code>&#39;s). This value is now, <code class="markup--code markup--p-code">25600</code> tokens (the value has been multiplied by <code class="markup--code markup--p-code">256</code>). In this example, if the exchange held this many tokens, the user would withdraw <code class="markup--code markup--p-code">25600</code> tokens (whilst the exchange thinks the user is only withdrawing <code class="markup--code markup--p-code">100</code>) to the modified address. Obviously the attacker wont posses the modified address in this example, but if the attacker where to generate any address which ended in <code class="markup--code markup--p-code">0</code>&#39;s (which can be easily brute forced) and used this generated address, they could easily steal tokens from the unsuspecting exchange.</p><h3 name="4dd4" id="4dd4" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="ca35" id="ca35" class="graf graf--p graf-after--h3">I suppose it is obvious to say that validating all inputs before sending them to the blockchain will prevent these kinds of attacks. It should also be noted that parameter ordering plays an important role here. As padding only occurs at the end, careful ordering of parameters in the smart contract can potentially mitigate some forms of this attack.</p><h3 name="923d" id="923d" class="graf graf--h3 graf-after--p">Real-World Example: Unknown</h3><p name="0902" id="0902" class="graf graf--p graf-after--h3">I do not know of any publicised attack of this kind in the wild.</p><h3 name="7259" id="7259" class="graf graf--h3 graf-after--p">9. Unchecked CALL Return Values</h3><p name="5d24" id="5d24" class="graf graf--p graf-after--h3">There a number of ways of performing external calls in solidity. Sending ether to external accounts is commonly done via the <code class="markup--code markup--p-code">transfer()</code> method. However, the <code class="markup--code markup--p-code">send()</code> function can also be used and, for more versatile external calls, the <code class="markup--code markup--p-code">CALL</code>opcode can be directly employed in solidity. The <code class="markup--code markup--p-code">call()</code> and <code class="markup--code markup--p-code">send()</code> functions return a boolean indicating if the call succeeded or failed. Thus these functions have a simple caveat, in that the transaction that executes these functions will not revert if the external call (intialised by <code class="markup--code markup--p-code">call()</code> or <code class="markup--code markup--p-code">send()</code>) fails, rather the <code class="markup--code markup--p-code">call()</code> or <code class="markup--code markup--p-code">send()</code> will simply return <code class="markup--code markup--p-code">false</code>. A common pitfall arises when the return value is not checked, rather the developer expects a revert to occur.</p><p name="31d3" id="31d3" class="graf graf--p graf-after--p">For further reading, see <a href="http://www.dasp.co/#item-4" data-href="http://www.dasp.co/#item-4" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">DASP Top 10</a> and <a href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/" data-href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Scanning Live Ethereum Contracts for the “Unchecked-Send” Bug</a>.</p><h3 name="6cf9" id="6cf9" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="543f" id="543f" class="graf graf--p graf-after--h3">Consider the following example:</p><figure name="e9a2" id="e9a2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/8872b02608ead7c8ae233d96c8aafe7e.js"></script></figure><p name="0c77" id="0c77" class="graf graf--p graf-after--figure">This contract represents a Lotto-like contract, where a <code class="markup--code markup--p-code">winner</code> receives <code class="markup--code markup--p-code">winAmount</code> of ether, which typically leaves a little left over for anyone to withdraw.</p><p name="16af" id="16af" class="graf graf--p graf-after--p">The bug exists on line [11] where a <code class="markup--code markup--p-code">send()</code> is used without checking the response. In this trivial example, a <code class="markup--code markup--p-code">winner</code> whose transaction fails (either by running out of gas, being a contract that intentionally throws in the fallback function or via a <a href="https://github.com/ethereum/wiki/wiki/Safety#call-depth-attack-deprecated" data-href="https://github.com/ethereum/wiki/wiki/Safety#call-depth-attack-deprecated" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">call stack depth attack</a>) allows <code class="markup--code markup--p-code">payedOut</code> to be set to <code class="markup--code markup--p-code">true</code> (regardless of whether ether was sent or not). In this case, the public can withdraw the <code class="markup--code markup--p-code">winner</code>&#39;s winnings via the <code class="markup--code markup--p-code">withdrawLeftOver()</code> function.</p><h3 name="1cff" id="1cff" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="6f3f" id="6f3f" class="graf graf--p graf-after--h3">Whenever possible, use the <code class="markup--code markup--p-code">transfer()</code> function rather than <code class="markup--code markup--p-code">send()</code> as <code class="markup--code markup--p-code">transfer()</code> will <code class="markup--code markup--p-code">revert</code> if the external transaction reverts. If <code class="markup--code markup--p-code">send()</code> is required, always ensure to check the return value.</p><p name="6051" id="6051" class="graf graf--p graf-after--p">An even more robust <a href="http://solidity.readthedocs.io/en/latest/common-patterns.html#withdrawal-from-contracts" data-href="http://solidity.readthedocs.io/en/latest/common-patterns.html#withdrawal-from-contracts" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">recommendation</a> is to adopt a <em class="markup--em markup--p-em">withdrawal pattern</em>. In this solution, each user is burdened with calling an isolated function (i.e. a <em class="markup--em markup--p-em">withdraw</em> function) which handles the sending of ether out of the contract and therefore independently deals with the consequences of failed send transactions. The idea is to logically isolate the external send functionality from the rest of the code base and place the burden of potentially failed transaction to the end-user who is calling the <em class="markup--em markup--p-em">withdraw</em> function.</p><h3 name="0aed" id="0aed" class="graf graf--h3 graf-after--p">Real-World Example: Etherpot and King of the Ether</h3><p name="ff3e" id="ff3e" class="graf graf--p graf-after--h3"><a href="https://github.com/etherpot" data-href="https://github.com/etherpot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Etherpot</a> was a smart contract lottery, not too dissimilar to the example contract mentioned above. The solidity code for etherpot, can be found here: <a href="https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol" data-href="https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">lotto.sol</a>. The primary downfall of this contract was due to an incorrect use of block hashes (only the last 256 block hashes are useable, see Aakil Fernandes’s <a href="http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks" data-href="http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">post</a> about how Etherpot failed to implement this correctly). However this contract also suffered from an unchecked call value. Notice the function, <code class="markup--code markup--p-code">cash()</code> on line [80] of lotto.sol:</p><figure name="fe2a" id="fe2a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/1ae4173cca15d71d9b551b33b0dae773.js"></script></figure><p name="42ce" id="42ce" class="graf graf--p graf-after--figure">Notice that on line [21] the send function’s return value is not checked, and the following line then sets a boolean indicating the winner has been sent their funds. This bug can allow a state where the winner does not receive their ether, but the state of the contract can indicate that the winner has already been paid.</p><p name="c3c1" id="c3c1" class="graf graf--p graf-after--p">A more serious version of this bug occurred in the <a href="https://www.kingoftheether.com/thrones/kingoftheether/index.html" data-href="https://www.kingoftheether.com/thrones/kingoftheether/index.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">King of the Ether</a>. An excellent <a href="https://www.kingoftheether.com/postmortem.html" data-href="https://www.kingoftheether.com/postmortem.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">post-mortem</a> of this contract has been written which details how an unchecked failed <code class="markup--code markup--p-code">send()</code> could be used to attack the contract.</p><h3 name="a061" id="a061" class="graf graf--h3 graf-after--p">10. Race Conditions / Front Running</h3><p name="8482" id="8482" class="graf graf--p graf-after--h3">The combination of external calls to other contracts and the multi-user nature of the underlying blockchain gives rise to a variety of potential Solidity pitfalls whereby users <em class="markup--em markup--p-em">race</em> code execution to obtain unexpected states. <a href="https://github.com/sigp/solidity-security-blog#reentrancy" data-href="https://github.com/sigp/solidity-security-blog#reentrancy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Re-Entrancy</a> is one example of such a race condition. In this section we will talk more generally about different kinds of race conditions that can occur on the Ethereum blockchain. There is a variety of good posts on this area, a few are: <a href="https://github.com/ethereum/wiki/wiki/Safety#race-conditions" data-href="https://github.com/ethereum/wiki/wiki/Safety#race-conditions" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethereum Wiki — Safety</a>, <a href="http://www.dasp.co/#item-7" data-href="http://www.dasp.co/#item-7" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">DASP — Front-Running</a> and the <a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions" data-href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Consensus — Smart Contract Best Practices</a>.</p><h3 name="ace3" id="ace3" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="2ead" id="2ead" class="graf graf--p graf-after--h3">As with most blockchains, Ethereum nodes pool transactions and form them into blocks. The transactions are only considered valid once a miner has solved a consensus mechanism (currently <a href="https://github.com/ethereum/wiki/wiki/Ethash" data-href="https://github.com/ethereum/wiki/wiki/Ethash" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ETHASH</a> PoW for Ethereum). The miner who solves the block also chooses which transactions from the pool will be included in the block, this is typically ordered by the <code class="markup--code markup--p-code">gasPrice</code> of a transaction. In here lies a potential attack vector. An attacker can watch the transaction pool for transactions which may contain solutions to problems, modify or revoke the attacker&#39;s permissions or change a state in a contract which is undesirable for the attacker. The attacker can then get the data from this transaction and create a transaction of their own with a higher <code class="markup--code markup--p-code">gasPrice</code> and get their transaction included in a block before the original.</p><p name="dd50" id="dd50" class="graf graf--p graf-after--p">Let’s see how this could work with a simple example. Consider the contract</p><h4 name="bc14" id="bc14" class="graf graf--h4 graf-after--p"><code class="markup--code markup--h4-code">FindThisHash.sol</code></h4><figure name="c1cf" id="c1cf" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/a733751d0e54f60c9c0df966bdd4a09f.js"></script></figure><p name="2690" id="2690" class="graf graf--p graf-after--figure">Imagine this contract contains 1000 ether. The user who can find the pre-image of the sha3 hash <code class="markup--code markup--p-code">0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a</code> can submit the solution and retrieve the 1000 ether. Lets say one user figures out the solution is <code class="markup--code markup--p-code">Ethereum!</code>. They call <code class="markup--code markup--p-code">solve()</code> with <code class="markup--code markup--p-code">Ethereum!</code> as the parameter. Unfortunately an attacker has been clever enough to watch the transaction pool for anyone submitting a solution. They see this solution, check it&#39;s validity, and then submit an equivalent transaction with a much higher <code class="markup--code markup--p-code">gasPrice</code> than the original transaction. The miner who solves the block will likely give the attacker preference due to the higher <code class="markup--code markup--p-code">gasPrice</code> and accept their transaction before the original solver. The attacker will take the 1000 ether and the user who solved the problem will get nothing (there is no ether left in the contract).</p><p name="2dff" id="2dff" class="graf graf--p graf-after--p">A more realistic problem comes in the design of the future Casper implementation. The Casper proof of stake contracts invoke slashing conditions where users who notice validators double-voting or misbehaving are incentivised to submit proof that they have done so. The validator will be punished and the user rewarded. In such a scenario, it is expected that miners and users will front-run all such submissions of proof, and this issue must be addressed before the final release.</p><h3 name="ed06" id="ed06" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="516e" id="516e" class="graf graf--p graf-after--h3">There are two classes of users who can perform these kinds of front-running attacks. Users (who modify the <code class="markup--code markup--p-code">gasPrice</code> of their transactions) and miners themselves (who can re-order the transactions in a block how they see fit). A contract that is vulnerable to the first class (users), is significantly worse-off than one vulnerable to the second (miners) as miner&#39;s can only perform the attack when they solve a block, which is unlikely for any individual miner targeting a specific block. Here I&#39;ll list a few mitigation measures with relation to which class of attackers they may prevent.</p><p name="c3f9" id="c3f9" class="graf graf--p graf-after--p">One method that can be employed is to create logic in the contract that places an upper bound on the <code class="markup--code markup--p-code">gasPrice</code>. This prevents users from increasing the <code class="markup--code markup--p-code">gasPrice</code> and getting preferential transaction ordering beyond the upper-bound. This preventative measure only mitigates the first class of attackers (arbitrary users). Miners in this scenario can still attack the contract as they can order the transactions in their block however they like, regardless of gas price.</p><p name="6eb0" id="6eb0" class="graf graf--p graf-after--p">A more robust method is to use a <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" data-href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">commit-reveal</a> scheme, whenever possible. Such a scheme dictates users send transactions with hidden information (typically a hash). After the transaction has been included in a block, the user sends a transaction revealing the data that was sent (the reveal phase). This method prevents both miners and users from frontrunning transactions as they cannot determine the contents of the transaction. This method however, cannot conceal the transaction value (which in some cases is the valuable information that needs to be hidden). The <a href="https://ens.domains/" data-href="https://ens.domains/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">ENS</a> smart contract allowed users to send transactions, whose committed data included the amount of ether they were willing to spend. Users could then send transactions of arbitrary value. During the reveal phase, users were refunded the difference between the amount sent in the transaction and the amount they were willing to spend.</p><p name="096c" id="096c" class="graf graf--p graf-after--p">A further suggestion by Lorenz, Phil, Ari and Florian is to use <a href="http://hackingdistributed.com/2017/08/28/submarine-sends/" data-href="http://hackingdistributed.com/2017/08/28/submarine-sends/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Submarine Sends</a>. An efficient implementation of this idea requires the <code class="markup--code markup--p-code">CREATE2</code> opcode, which currently hasn&#39;t been adopted, but seems likely in upcoming hard forks.</p><h3 name="d8a1" id="d8a1" class="graf graf--h3 graf-after--p">Real-World Examples: ERC20 and Bancor</h3><p name="9552" id="9552" class="graf graf--p graf-after--h3">The <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a> standard is quite well-known for building tokens on Ethereum. This standard has a potential frontrunning vulnerability which comes about due to the <code class="markup--code markup--p-code">approve()</code> function. A good explanation of this vulnerability can be found <a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" data-href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>.</p><p name="dfd2" id="dfd2" class="graf graf--p graf-after--p">The standard specifies the <code class="markup--code markup--p-code">approve()</code> function as:</p><pre name="e593" id="e593" class="graf graf--pre graf-after--p">function approve(address _spender, uint256 _value) returns (bool success)</pre><p name="2b62" id="2b62" class="graf graf--p graf-after--pre">This function allows a user to permit other users to transfer tokens on their behalf. The frontrunning vulnerability comes in the scenario when a user, Alice, <em class="markup--em markup--p-em">approves</em> her friend, <code class="markup--code markup--p-code">Bob</code> to spend <code class="markup--code markup--p-code">100 tokens</code>. Alice later decides that she wants to revoke <code class="markup--code markup--p-code">Bob</code>&#39;s approval to spend <code class="markup--code markup--p-code">100 tokens</code>, so she creates a transaction that sets <code class="markup--code markup--p-code">Bob</code>&#39;s allocation to <code class="markup--code markup--p-code">50 tokens</code>. <code class="markup--code markup--p-code">Bob</code>, who has been carefully watching the chain, sees this transaction and builds a transaction of his own spending the <code class="markup--code markup--p-code">100 tokens</code>. He puts a higher <code class="markup--code markup--p-code">gasPrice</code> on his transaction than <code class="markup--code markup--p-code">Alice</code>&#39;s and gets his transaction prioritised over hers. Some implementations of <code class="markup--code markup--p-code">approve()</code> would allow <code class="markup--code markup--p-code">Bob</code> to transfer his <code class="markup--code markup--p-code">100 tokens</code>, then when <code class="markup--code markup--p-code">Alice</code>&#39;s transaction gets committed, resets <code class="markup--code markup--p-code">Bob</code>&#39;s approval to <code class="markup--code markup--p-code">50 tokens</code>, in effect giving <code class="markup--code markup--p-code">Bob</code> access to <code class="markup--code markup--p-code">150 tokens</code>. The mitigation strategies of this attack are given <a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" data-href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a> in the document linked above.</p><p name="df28" id="df28" class="graf graf--p graf-after--p">Another prominent, real-world example is <a href="https://www.bancor.network/" data-href="https://www.bancor.network/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Bancor</a>. Ivan Bogatty and his team documented a profitable attack on the initial Bancor implementation. His <a href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798" data-href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">blog post</a> and <a href="https://www.youtube.com/watch?v=RL2nE3huNiI" data-href="https://www.youtube.com/watch?v=RL2nE3huNiI" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Devon 3 talk</a> discuss in detail how this was done. Essentially, prices of tokens are determined based on transaction value, users can watch the transaction pool for Bancor transactions and front run them to profit from the price differences. This attack has been addressed by the Bancor team.</p><h3 name="7b4b" id="7b4b" class="graf graf--h3 graf-after--p">11. Denial Of Service (DOS)</h3><p name="2645" id="2645" class="graf graf--p graf-after--h3">This category is very broad, but fundamentally consists of attacks where users can leave the contract inoperable for a small period of time, or in some cases, permanently. This can trap ether in these contracts forever, as was the case with the <a href="https://github.com/sigp/solidity-security-blog#dc-example" data-href="https://github.com/sigp/solidity-security-blog#dc-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Second Parity MultiSig hack</a></p><h3 name="76ae" id="76ae" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="7b4a" id="7b4a" class="graf graf--p graf-after--h3">There are various ways a contract can become inoperable. Here I will only highlight some potentially less-obvious Blockchain nuanced Solidity coding patterns that can lead to attackers performing DOS attacks.</p><ol class="postList"><li name="ace9" id="ace9" class="graf graf--li graf-after--p">Looping through externally manipulated mappings or arrays — In my adventures I’ve seen various forms of this kind of pattern. Typically it appears in scenarios where an <code class="markup--code markup--li-code">owner</code> wishes to distribute tokens amongst their investors, and do so with a <code class="markup--code markup--li-code">distribute()</code>-like function as can be seen in the example contract:</li></ol><figure name="d4c6" id="d4c6" class="graf graf--figure graf--iframe graf-after--li"><script src="https://gist.github.com/vasa-develop/6bc70e63ae1d4eaf8587599bca383387.js"></script></figure><p name="a779" id="a779" class="graf graf--p graf-after--figure">Notice that the loop in this contract runs over an array which can be artificially inflated. An attacker can create many user accounts making the <code class="markup--code markup--p-code">investor</code> array large. In principle this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the <code class="markup--code markup--p-code">distribute()</code> function inoperable.</p><p name="d10b" id="d10b" class="graf graf--p graf-after--p">2. Owner operations — Another common pattern is where owner’s have specific privileges in contracts and must perform some task in order for the contract to proceed to the next state. One example would be an ICO contract that requires the owner to <code class="markup--code markup--p-code">finalize()</code> the contract which then allows tokens to be transferable, i.e.</p><figure name="a5ee" id="a5ee" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/32b7472991feaeda33e5eb96af980d7a.js"></script></figure><p name="9970" id="9970" class="graf graf--p graf-after--figure">In such cases, if a privileged user loses their private keys, or becomes inactive, the entire token contract becomes inoperable. In this case, if the <code class="markup--code markup--p-code">owner</code> cannot call <code class="markup--code markup--p-code">finalize()</code> no tokens can be transferred; i.e. the entire operation of the token ecosystem hinges on a single address.</p><p name="572e" id="572e" class="graf graf--p graf-after--p">3. Progressing state based on external calls — Contracts are sometimes written such that in order to progress to a new state requires sending ether to an address, or waiting for some input from an external source. These patterns can lead to DOS attacks, when the external call fails, or is prevented for external reasons. In the example of sending ether, a user can create a contract which doesn’t accept ether. If a contract needs to send ether to this address in order to progress to a new state, the contract will never achieve the new state as ether can never be sent to the contract.</p><h3 name="b350" id="b350" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="9806" id="9806" class="graf graf--p graf-after--h3">In the first example, contracts should not loop through data structures that can be artificially manipulated by external users. A withdrawal pattern is recommended, whereby each of the investors call a withdraw function to claim tokens independently.</p><p name="1beb" id="1beb" class="graf graf--p graf-after--p">In the second example a privileged user was required to change the state of the contract. In such examples (wherever possible) a fail-safe can be used in the event that the <code class="markup--code markup--p-code">owner</code> becomes incapacitated. One solution could be setting up the <code class="markup--code markup--p-code">owner</code> as a multisig contract. Another solution is to use a timelock, where the require on line [13] could include a time-based mechanism, such as <code class="markup--code markup--p-code">require(msg.sender == owner || now &gt; unlockTime)</code> which allows any user to finalise after a period of time, specified by <code class="markup--code markup--p-code">unlockTime</code>. This kind of mitigation technique can be used in the third example also. If external calls are required to progress to a new state, account for their possible failure and potentially add a time-based state progression in the event that the desired call never comes.</p><p name="cb1a" id="cb1a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Note: Of course there are centralised alternatives to these suggestions where one can add a </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">maintenanceUser</em></code><em class="markup--em markup--p-em"> who can come along and fix problems with DOS-based attack vectors if need be. Typically these kinds of contracts contain trust issues over the power of such an entity, but that is not a conversation for this section.</em></p><h3 name="f172" id="f172" class="graf graf--h3 graf-after--p">Real-World Examples: GovernMental</h3><p name="ceb7" id="ceb7" class="graf graf--p graf-after--h3"><a href="http://governmental.github.io/GovernMental/" data-href="http://governmental.github.io/GovernMental/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">GovernMental</a> was an old Ponzi scheme that accumulated quite a large amount of ether. In fact, at one point it had accumulated 1100 ether. Unfortunately, it was susceptible to the DOS vulnerabilities mentioned in this section. <a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" data-href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">This Reddit Post</a> describes how the contract required the deletion of a large mapping in order to withdraw the ether. The deletion of this mapping had a gas cost that exceeded the block gas limit at the time, and thus was not possible to withdraw the 1100 ether. The contract address is <a href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3" data-href="https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">0xF45717552f12Ef7cb65e95476F217Ea008167Ae3</a> and you can see from transaction <a href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b" data-href="https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b</a> that the 1100 ether was finally obtained with a transaction that used 2.5M gas.</p><h3 name="689b" id="689b" class="graf graf--h3 graf-after--p">12. Block Timestamp Manipulation</h3><p name="130b" id="130b" class="graf graf--p graf-after--h3">Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the <a href="https://github.com/sigp/solidity-security-blog#entropy" data-href="https://github.com/sigp/solidity-security-blog#entropy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Entropy Illusion</a> section for further details), locking funds for periods of time and various state-changing conditional statements that are time-dependent. Miner’s have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts.</p><p name="55b6" id="55b6" class="graf graf--p graf-after--p">Some useful references for this are: <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" data-href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">The Solidity Docs</a>, this <a href="https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" data-href="https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Stack Exchange Question</a>,</p><h3 name="cd9e" id="cd9e" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="eecf" id="eecf" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">block.timestamp</code> or its alias <code class="markup--code markup--p-code">now</code> can be manipulated by miners if they have some incentive to do so. Lets construct a simple game, which would be vulnerable to miner exploitation,</p><h4 name="a57c" id="a57c" class="graf graf--h4 graf-after--p"><code class="markup--code markup--h4-code">Roulette.sol</code></h4><figure name="4b56" id="4b56" class="graf graf--figure graf--iframe graf-after--h4"><script src="https://gist.github.com/vasa-develop/b7724a85b68600e2c688da0b233313b8.js"></script></figure><p name="3a1d" id="3a1d" class="graf graf--p graf-after--figure">This contract behaves like a simple lottery. One transaction per block can bet <code class="markup--code markup--p-code">10 ether</code> for a chance to win the balance of the contract. The assumption here is that, <code class="markup--code markup--p-code">block.timestamp</code> is uniformly distributed about the last two digits. If that were the case, there would be a 1/15 chance of winning this lottery.</p><p name="17f3" id="17f3" class="graf graf--p graf-after--p">However, as we know, miners can adjust the timestamp, should they need to. In this particular case, if enough ether pooled in the contract, a miner who solves a block is incentivised to choose a timestamp such that <code class="markup--code markup--p-code">block.timestamp</code> or <code class="markup--code markup--p-code">now</code> modulo 15 is <code class="markup--code markup--p-code">0</code>. In doing so they may win the ether locked in this contract along with the block reward. As there is only one person allowed to bet per block, this is also vulnerable to <a href="https://github.com/sigp/solidity-security-blog#race-conditions" data-href="https://github.com/sigp/solidity-security-blog#race-conditions" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">front-running</a> attacks.</p><p name="a5e0" id="a5e0" class="graf graf--p graf-after--p">In practice, block timestamps are monotonically increasing and so miners cannot choose arbitrary block timestamps (they must be larger than their predecessors). They are also limited to setting blocktimes not too far in the future as these blocks will likely be rejected by the network (nodes will not validate blocks whose timestamps are in the future).</p><h3 name="540d" id="540d" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="634c" id="634c" class="graf graf--p graf-after--h3">Block timestamps should not be used for entropy or generating random numbers — i.e. they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state (if assumed to be random).</p><p name="b525" id="b525" class="graf graf--p graf-after--p">Time-sensitive logic is sometimes required; i.e. unlocking contracts (timelocking), completing an ICO after a few weeks or enforcing expiry dates. It is sometimes recommend to use <code class="markup--code markup--p-code">block.number</code> (see the <a href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" data-href="http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity docs</a>) and an average block time to estimate times; .i.e. <code class="markup--code markup--p-code">1 week</code> with a <code class="markup--code markup--p-code">10 second</code> block time, equates to approximately, <code class="markup--code markup--p-code">60480 blocks</code>. Thus, specifying a block number at which to change a contract state can be more secure as miners are unable to manipulate the block number as easily. The <a href="https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code" data-href="https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">BAT ICO</a> contract employed this strategy.</p><p name="8983" id="8983" class="graf graf--p graf-after--p">This can be unnecessary if contracts aren’t particularly concerned with miner manipulations of the block timestamp, but it is something to be aware of when developing contracts.</p><h3 name="d13e" id="d13e" class="graf graf--h3 graf-after--p">Real-World Example: GovernMental</h3><p name="8c8f" id="8c8f" class="graf graf--p graf-after--h3"><a href="http://governmental.github.io/GovernMental/" data-href="http://governmental.github.io/GovernMental/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">GovernMental</a> was an old Ponzi scheme that accumulated quite a large amount of ether. It was also vulnerable to a timestamp-based attack. The contract payed out to the player who was the last player to join (for at least one minute) in a round. Thus, a miner who was a player, could adjust the timestamp (to a future time, to make it look like a minute had elapsed) to make it appear that the player was the last to join for over a minute (even though this is not true in reality). More detail on this can be found in the <a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes" data-href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">History of Ethereum Security Vulnerabilities Post</a> by Tanya Bahrynovska.</p><h3 name="8a2c" id="8a2c" class="graf graf--h3 graf-after--p">13. Constructors with Care</h3><p name="4a4b" id="4a4b" class="graf graf--p graf-after--h3">Constructors are special functions which often perform critical, privileged tasks when initialising contracts. Before solidity <code class="markup--code markup--p-code">v0.4.22</code> constructors were defined as functions that had the same name as the contract that contained them. Thus, when a contract name gets changed in development, if the constructor name isn&#39;t changed, it becomes a normal, callable function. As you can imagine, this can (and has) lead to some interesting contract hacks.</p><p name="81a9" id="81a9" class="graf graf--p graf-after--p">For further reading, I suggest the reader attempt the <a href="https://github.com/OpenZeppelin/ethernaut" data-href="https://github.com/OpenZeppelin/ethernaut" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethernaught Challenges</a> (in particular the Fallout level).</p><h3 name="2e10" id="2e10" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="3bc2" id="3bc2" class="graf graf--p graf-after--h3">If the contract name gets modified, or there is a typo in the constructors name such that it no longer matches the name of the contract, the constructor will behave like a normal function. This can lead to dire consequences, especially if the constructor is performing privileged operations. Consider the following contract</p><figure name="7ba0" id="7ba0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/190050f6cfd58902701e0796489d159f.js"></script></figure><p name="03e0" id="03e0" class="graf graf--p graf-after--figure">This contract collects ether and only allows the owner to withdraw all the ether by calling the <code class="markup--code markup--p-code">withdraw()</code> function. The issue arises due to the fact that the constructor is not exactly named after the contract. Specifically, <code class="markup--code markup--p-code">ownerWallet</code> is not the same as <code class="markup--code markup--p-code">OwnerWallet</code>. Thus, any user can call the <code class="markup--code markup--p-code">ownerWallet()</code> function, set themselves as the owner and then take all the ether in the contract by calling <code class="markup--code markup--p-code">withdraw()</code>.</p><h3 name="680c" id="680c" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="679d" id="679d" class="graf graf--p graf-after--h3">This issue has been primarily addressed in the Solidity compiler in version <code class="markup--code markup--p-code">0.4.22</code>. This version introduced a <code class="markup--code markup--p-code">constructor</code>keyword which specifies the constructor, rather than requiring the name of the function to match the contract name. Using this keyword to specify constructors is recommended to prevent naming issues as highlighted above.</p><h3 name="5d35" id="5d35" class="graf graf--h3 graf-after--p">Real-World Example: Rubixi</h3><p name="0973" id="0973" class="graf graf--p graf-after--h3">Rubixi (<a href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code" data-href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">contract code</a>) was another pyramid scheme that exhibited this kind of vulnerability. It was originally called <code class="markup--code markup--p-code">DynamicPyramid</code> but the contract name was changed before deployment to <code class="markup--code markup--p-code">Rubixi</code>. The constructor&#39;s name wasn&#39;t changed, allowing any user to become the <code class="markup--code markup--p-code">creator</code>. Some interesting discussion related to this bug can be found on this <a href="https://bitcointalk.org/index.php?topic=1400536.60" data-href="https://bitcointalk.org/index.php?topic=1400536.60" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Bitcoin Thread</a>. Ultimately, it allowed users to fight for <code class="markup--code markup--p-code">creator</code> status to claim the fees from the pyramid scheme. More detail on this particular bug can be found <a href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes" data-href="https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>.</p><h3 name="9d70" id="9d70" class="graf graf--h3 graf-after--p">14. Unintialised Storage Pointers</h3><p name="993e" id="993e" class="graf graf--p graf-after--h3">The EVM stores data either as <code class="markup--code markup--p-code">storage</code> or as <code class="markup--code markup--p-code">memory</code>. Understanding exactly how this is done and the default types for local variables of functions is highly recommended when developing contracts. This is because it is possible to produce vulnerable contracts by inappropriately intialising variables.</p><p name="22de" id="22de" class="graf graf--p graf-after--p">To read more about <code class="markup--code markup--p-code">storage</code> and <code class="markup--code markup--p-code">memory</code> in the EVM, see the <a href="http://solidity.readthedocs.io/en/latest/types.html#data-location" data-href="http://solidity.readthedocs.io/en/latest/types.html#data-location" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs: Data Location</a>, <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" data-href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs: Layout of State Variables in Storage</a>, <a href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory" data-href="http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Solidity Docs: Layout in Memory</a>.</p><p name="06bf" id="06bf" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">This section is based off the excellent </em><a href="https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743" data-href="https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank"><em class="markup--em markup--p-em">post by Stefan Beyer</em></a><em class="markup--em markup--p-em">. Further reading on this topic can be found from Sefan’s inspiration, which is this </em><a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" data-href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank"><em class="markup--em markup--p-em">reddit thread</em></a><em class="markup--em markup--p-em">.</em></p><h3 name="0782" id="0782" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="8869" id="8869" class="graf graf--p graf-after--h3">Local variables within functions default to <code class="markup--code markup--p-code">storage</code> or <code class="markup--code markup--p-code">memory</code> depending on their type. Uninitialised local <code class="markup--code markup--p-code">storage</code> variables can point to other unexpected storage variables in the contract, leading to intentional (i.e. the developer intentionally puts them there to attack later) or unintentional vulnerabilities.</p><p name="882e" id="882e" class="graf graf--p graf-after--p">Let’s consider the following, relatively simple name registrar contract:</p><figure name="5938" id="5938" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/82c2de027242c909064d65d69395d72b.js"></script></figure><p name="387c" id="387c" class="graf graf--p graf-after--figure">This simple name registrar has only one function. When the contract is <code class="markup--code markup--p-code">unlocked</code>, it allows anyone to register a name (as a <code class="markup--code markup--p-code">bytes32</code> hash) and map that name to an address. Unfortunately, this registrar is initially locked and the <code class="markup--code markup--p-code">require</code> on line [23] prevents <code class="markup--code markup--p-code">register()</code> from adding name records. There is however a vulnerability in this contract, that allows name registration regardless of the <code class="markup--code markup--p-code">unlocked</code> variable.</p><p name="2476" id="2476" class="graf graf--p graf-after--p">To discuss this vulnerability, first we need to understand how storage works in Solidity. As a high level overview (without any proper technical detail — I suggest reading the Solidity docs for a proper review), state variables are stored sequentially in <em class="markup--em markup--p-em">slots</em>as they appear in the contract (they can be grouped together, but not in this example, so we wont worry about that). Thus, <code class="markup--code markup--p-code">unlocked</code> exists in <code class="markup--code markup--p-code">slot 0</code>, <code class="markup--code markup--p-code">registeredNameRecord</code> exists in <code class="markup--code markup--p-code">slot 1</code> and <code class="markup--code markup--p-code">resolve</code> in <code class="markup--code markup--p-code">slot 2</code> etc. Each of these slots are of byte size 32 (there are added complexities with mappings which we ignore for now). The boolean <code class="markup--code markup--p-code">unlocked</code> will look like <code class="markup--code markup--p-code">0x000...0</code> (64 <code class="markup--code markup--p-code">0</code>&#39;s, excluding the <code class="markup--code markup--p-code">0x</code>) for <code class="markup--code markup--p-code">false</code> or <code class="markup--code markup--p-code">0x000...1</code>(63 <code class="markup--code markup--p-code">0</code>&#39;s) for <code class="markup--code markup--p-code">true</code>. As you can see, there is a significant waste of storage in this particular example.</p><p name="03f2" id="03f2" class="graf graf--p graf-after--p">The next piece of information that we need, is that Solidity defaults complex data types, such as <code class="markup--code markup--p-code">structs</code>, to <code class="markup--code markup--p-code">storage</code> when initialising them as local variables. Therefore, <code class="markup--code markup--p-code">newRecord</code> on line [16] defaults to <code class="markup--code markup--p-code">storage</code>. The vulnerability is caused by the fact that <code class="markup--code markup--p-code">newRecord</code> is not initialised. Because it defaults to storage, it becomes a pointer to storage and because it is uninitialised, it points to slot <code class="markup--code markup--p-code">0</code> (i.e. where <code class="markup--code markup--p-code">unlocked</code> is stored). Notice that on lines [17] and [18] we then set <code class="markup--code markup--p-code">nameRecord.name</code> to <code class="markup--code markup--p-code">_name</code> and <code class="markup--code markup--p-code">nameRecord.mappedAddress</code> to <code class="markup--code markup--p-code">_mappedAddress</code>, this in effect changes the storage location of slot 0 and slot 1 which modifies both <code class="markup--code markup--p-code">unlocked</code> and the storage slot associated with <code class="markup--code markup--p-code">registeredNameRecord</code>.</p><p name="4b10" id="4b10" class="graf graf--p graf-after--p">This means that <code class="markup--code markup--p-code">unlocked</code> can be directly modified, simply by the <code class="markup--code markup--p-code">bytes32 _name</code> parameter of the <code class="markup--code markup--p-code">register()</code> function. Therefore, if the last byte of <code class="markup--code markup--p-code">_name</code> is non-zero, it will modify the last byte of storage <code class="markup--code markup--p-code">slot 0</code> and directly change <code class="markup--code markup--p-code">unlocked</code>to <code class="markup--code markup--p-code">true</code>. Such <code class="markup--code markup--p-code">_name</code> values will pass the <code class="markup--code markup--p-code">require()</code> on line [23] as we are setting <code class="markup--code markup--p-code">unlocked</code> to <code class="markup--code markup--p-code">true</code>. Try this in Remix. Notice the function will pass if you use a <code class="markup--code markup--p-code">_name</code> of the form: <code class="markup--code markup--p-code">0x0000000000000000000000000000000000000000000000000000000000000001</code></p><h3 name="e895" id="e895" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="37b1" id="37b1" class="graf graf--p graf-after--h3">The Solidity compiler raises unintialised storage variables as warnings, thus developers should pay careful attention to these warnings when building smart contracts. The current version of mist (0.10), doesn’t allow these contracts to be compiled. It is often good practice to explicitly use the <code class="markup--code markup--p-code">memory</code> or <code class="markup--code markup--p-code">storage</code> when dealing with complex types to ensure they behave as expected.</p><h3 name="994f" id="994f" class="graf graf--h3 graf-after--p">Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRoulette</h3><p name="444a" id="444a" class="graf graf--p graf-after--h3">A honey pot named OpenAddressLottery (<a href="https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code" data-href="https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">contract code</a>) was deployed that used this uninitialised storage variable querk to collect ether from some would-be hackers. The contract is rather in-depth, so I will leave the discussion to this <a href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" data-href="https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">reddit thread</a>where the attack is quite clearly explained.</p><p name="fe8a" id="fe8a" class="graf graf--p graf-after--p">Another honey pot, CryptoRoulette (<a href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code" data-href="https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">contract code</a>) also utilises this trick to try and collect some ether. If you can’t figure out how the attack works, see <a href="https://medium.com/@jsanjuas/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d" data-href="https://medium.com/@jsanjuas/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">An analysis of a couple Ethereum honeypot contracts</a> for an overview of this contract and others.</p><h3 name="4431" id="4431" class="graf graf--h3 graf-after--p">15. Floating Points and Precision</h3><p name="f3ff" id="f3ff" class="graf graf--p graf-after--h3">As of this writing (Solidity v0.4.24), fixed point or floating point numbers are not supported. This means that floating point representations must be made with the integer types in Solidity. This can lead to errors/vulnerabilities if not implemented correctly.</p><p name="10e4" id="10e4" class="graf graf--p graf-after--p">For further reading, see <a href="https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division" data-href="https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethereum Contract Security Techniques and Tips — Rounding with Integer Division</a>,</p><h3 name="767c" id="767c" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="4b2a" id="4b2a" class="graf graf--p graf-after--h3">As there is no fixed point type in Solidity, developers are required to implement their own using the standard integer data types. There are a number of pitfalls developers can run into during this process. I will try to highlight some of these in this section.</p><p name="7f9f" id="7f9f" class="graf graf--p graf-after--p">Lets begin with a code example (lets ignore any over/under flow issues for simplicity).</p><figure name="b11a" id="b11a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/82759590bd44a23fd6d1344e1035fdce.js"></script></figure><p name="d78f" id="d78f" class="graf graf--p graf-after--figure">This simple token buying/selling contract has some obvious problems in the buying and selling of tokens. Although the mathematical calculations for buying and selling tokens are correct, the lack of floating point numbers will give erroneous results. For example, when buying tokens on line [7], if the value is less than <code class="markup--code markup--p-code">1 ether</code> the initial division will result in <code class="markup--code markup--p-code">0</code>, leaving the final multiplication <code class="markup--code markup--p-code">0</code> (i.e. <code class="markup--code markup--p-code">200 wei</code> divided by <code class="markup--code markup--p-code">1e18</code> <code class="markup--code markup--p-code">weiPerEth</code> equals <code class="markup--code markup--p-code">0</code>). Similarly, when selling tokens, any tokens less than <code class="markup--code markup--p-code">10</code> will also result in <code class="markup--code markup--p-code">0 ether</code>. In fact, rounding here is always down, so selling <code class="markup--code markup--p-code">29 tokens</code>, will result in <code class="markup--code markup--p-code">2 ether</code>.</p><p name="743c" id="743c" class="graf graf--p graf-after--p">The issue with this contract is that the precision is only to the nearest <code class="markup--code markup--p-code">ether</code> (i.e. <code class="markup--code markup--p-code">1e18 wei</code>). This can sometimes get tricky when dealing with <code class="markup--code markup--p-code">decimals</code> in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20</a> tokens when you need higher precisions.</p><h3 name="e4ea" id="e4ea" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="f790" id="f790" class="graf graf--p graf-after--h3">Keeping the right precision in your smart contracts is very important, especially when dealing ratios and rates which reflect economic decisions.</p><p name="d089" id="d089" class="graf graf--p graf-after--p">You should ensure that any ratios or rates you are using allow for large numerators in fractions. For example, we used the rate <code class="markup--code markup--p-code">tokensPerEth</code> in our example. It would have been better to use <code class="markup--code markup--p-code">weiPerTokens</code> which would be a large number. To solve for the amount of tokens we could do <code class="markup--code markup--p-code">msg.sender/weiPerTokens</code>. This would give a more precise result.</p><p name="2497" id="2497" class="graf graf--p graf-after--p">Another tactic to keep in mind, is to be mindful of order of operations. In the above example, the calculation to purchase tokens was <code class="markup--code markup--p-code">msg.value/weiPerEth*tokenPerEth</code>. Notice that the division occurs before the multiplication. This example would have achieved a greater precision if the calculation performed the multiplication first and then the division, i.e. <code class="markup--code markup--p-code">msg.value*tokenPerEth/weiPerEth</code>.</p><p name="4bcc" id="4bcc" class="graf graf--p graf-after--p">Finally, when defining arbitrary precision for numbers it can be a good idea to convert variables into higher precision, perform all mathematical operations, then finally when needed, convert back down to the precision for output. Typically <code class="markup--code markup--p-code">uint256</code>&#39;s are used (as they are optimal for gas usage) which give approximately 60 orders of magnitude in their range, some which can be dedicated to the precision of mathematical operations. It may be the case that it is better to keep all variables in high precision in solidity and convert back to lower precisions in external apps (this is essentially how the <code class="markup--code markup--p-code">decimals</code> variable works in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ERC20 Token</a> contracts). To see examples of how this can be done and the libraries to do this, I recommend looking at the <a href="https://github.com/dapphub/ds-math" data-href="https://github.com/dapphub/ds-math" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Maker DAO DSMath</a>. They use some funky naming, <code class="markup--code markup--p-code">WAD</code>&#39;s and <code class="markup--code markup--p-code">RAY</code>&#39;s but the concept is useful.</p><h3 name="c19d" id="c19d" class="graf graf--h3 graf-after--p">Real-World Example: Ethstick</h3><p name="890f" id="890f" class="graf graf--p graf-after--h3">I couldn’t find a good example where rounding has caused a severe issue in a contract, but I’m sure there are plenty out there. Feel free to update this if you have a good one in mind.</p><p name="ae68" id="ae68" class="graf graf--p graf-after--p">For lack of a good example, I want to draw your attention to <a href="https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code" data-href="https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethstick</a> mainly because I like the cool naming within the contract. This contract doesn’t use any extended precision, however, it deals with <code class="markup--code markup--p-code">wei</code>. So this contract will have issues of rounding, but only at the <code class="markup--code markup--p-code">wei</code> level of precision. It has some more serious flaws, but these are relating back to the difficulty in getting entropy on the blockchain (see <a href="https://github.com/sigp/solidity-security-blog#entropy-illusion" data-href="https://github.com/sigp/solidity-security-blog#entropy-illusion" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Entropty Illusion</a>). For a further discussion on the Ethstick contract, I&#39;ll refer you to another post of Peter Venesses, <a href="https://vessenes.com/ethereum-contracts-are-going-to-be-candy-for-hackers/" data-href="https://vessenes.com/ethereum-contracts-are-going-to-be-candy-for-hackers/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethereum Contracts Are Going to be Candy For Hackers</a>.</p><h3 name="fb3b" id="fb3b" class="graf graf--h3 graf-after--p">16. Tx.Origin Authentication</h3><p name="f60e" id="f60e" class="graf graf--p graf-after--h3">Solidity has a global variable, <code class="markup--code markup--p-code">tx.origin</code> which traverses the entire call stack and returns the address of the account that originally sent the call (or transaction). Using this variable for authentication in smart contracts leaves the contract vulnerable to a phishing-like attack.</p><p name="8196" id="8196" class="graf graf--p graf-after--p">For further reading, see <a href="https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin" data-href="https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Stack Exchange Question</a>, <a href="https://vessenes.com/tx-origin-and-ethereum-oh-my/" data-href="https://vessenes.com/tx-origin-and-ethereum-oh-my/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Peter Venesses’s Blog</a> and <a href="https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514" data-href="https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">Solidity — Tx.Origin attacks</a>.</p><h3 name="4a25" id="4a25" class="graf graf--h3 graf-after--p">The Vulnerability</h3><p name="c2c1" id="c2c1" class="graf graf--p graf-after--h3">Contracts that authorise users using the <code class="markup--code markup--p-code">tx.origin</code> variable are typically vulnerable to phishing attacks which can trick users into performing authenticated actions on the vulnerable contract.</p><p name="67af" id="67af" class="graf graf--p graf-after--p">Consider the simple contract,</p><figure name="64fc" id="64fc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/ef905637bb4bad2daf57d120e1d3c253.js"></script></figure><p name="bc90" id="bc90" class="graf graf--p graf-after--figure">Notice that on line [11] this contract authorises the <code class="markup--code markup--p-code">withdrawAll()</code> function using <code class="markup--code markup--p-code">tx.origin</code>. This contract allows for an attacker to create an attacking contract of the form,</p><figure name="d2b0" id="d2b0" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/vasa-develop/0b1e458f4555fcdfd3b1f8f9d8be85a5.js"></script></figure><p name="31df" id="31df" class="graf graf--p graf-after--figure">To utilise this contract, an attacker would deploy it, and then convince the owner of the <code class="markup--code markup--p-code">Phishable</code> contract to send this contract some amount of ether. The attacker may disguise this contract as their own private address and social engineer the victim to send some form of transaction to the address. The victim, unless being careful, may not notice that there is code at the attacker&#39;s address, or the attacker may pass it off as being a multisignature wallet or some advanced storage wallet.</p><p name="1844" id="1844" class="graf graf--p graf-after--p">In any case, if the victim sends a transaction (with enough gas) to the <code class="markup--code markup--p-code">AttackContract</code> address, it will invoke the fallback function, which in turn calls the <code class="markup--code markup--p-code">withdrawAll()</code> function of the <code class="markup--code markup--p-code">Phishable</code> contract, with the parameter <code class="markup--code markup--p-code">attacker</code>. This will result in the withdrawal of all funds from the <code class="markup--code markup--p-code">Phishable</code> contract to the <code class="markup--code markup--p-code">attacker</code> address. This is because the address that first initialised the call was the victim (i.e. the <code class="markup--code markup--p-code">owner</code> of the <code class="markup--code markup--p-code">Phishable</code> contract). Therefore, <code class="markup--code markup--p-code">tx.origin</code> will be equal to <code class="markup--code markup--p-code">owner</code> and the <code class="markup--code markup--p-code">require</code> on line [11] of the <code class="markup--code markup--p-code">Phishable</code> contract will pass.</p><h3 name="ec0a" id="ec0a" class="graf graf--h3 graf-after--p">Preventative Techniques</h3><p name="6f95" id="6f95" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">tx.origin</code> should not be used for authorisation in smart contracts. This isn&#39;t to say that the <code class="markup--code markup--p-code">tx.origin</code> variable should never be used. It does have some legitimate use cases in smart contracts. For example, if one wanted to deny external contracts from calling the current contract, they could implement a <code class="markup--code markup--p-code">require</code> of the from <code class="markup--code markup--p-code">require(tx.origin == msg.sender)</code>. This prevents intermediate contracts being used to call the current contract, limiting the contract to regular code-less addresses.</p><h3 name="ea07" id="ea07" class="graf graf--h3 graf-after--p">Real-World Example: Not Known</h3><p name="6ae1" id="6ae1" class="graf graf--p graf-after--h3 graf--trailing">I do not know of any publicised exploits of this form in the wild.</p></div></div></section><section name="2247" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5e64" id="5e64" class="graf graf--h3 graf--leading">Ethereum Quirks</h3><p name="c0fe" id="c0fe" class="graf graf--p graf-after--h3">I intend to populate this section with various interesting quirks that get discovered by the community. These are kept in this blog as they may aid in smart contract development if one were to utilize these quirks in practice.</p><h3 name="ad85" id="ad85" class="graf graf--h3 graf-after--p">Keyless Ether</h3><p name="1e68" id="1e68" class="graf graf--p graf-after--h3">Contract addresses are deterministic, meaning that they can be calculated prior to actually creating the address. This is the case for addresses creating contracts and also for contracts spawning other contracts. In fact, a created contract’s address is determined by:</p><p name="e6ca" id="e6ca" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">keccak256(rlp.encode([&lt;account_address&gt;, &lt;transaction_nonce&gt;])</code></p><p name="75d6" id="75d6" class="graf graf--p graf-after--p">Essentially, a contract’s address is just the <code class="markup--code markup--p-code">keccak256</code> hash of the account that created it concatenated with the accounts transaction nonce(A transaction nonce is like a transaction counter. It increments ever time a transaction is sent from your account.). The same is true for contracts, except contracts nonce&#39;s start at <code class="markup--code markup--p-code">1</code> whereas address&#39;s transaction nonce&#39;s start at <code class="markup--code markup--p-code">0</code>.</p><p name="95d6" id="95d6" class="graf graf--p graf-after--p">This means that given an Ethereum address, we can calculate all the possible contract addresses that this address can spawn. For example, if the address <code class="markup--code markup--p-code">0x123000...000</code> were to create a contract on its 100th transaction, it would create the contract address <code class="markup--code markup--p-code">keccak256(rlp.encode[0x123...000, 100])</code>, which would give the contract address, <code class="markup--code markup--p-code">0xed4cafc88a13f5d58a163e61591b9385b6fe6d1a</code>.</p><p name="a6dd" id="a6dd" class="graf graf--p graf-after--p">What does this all mean? This means that you can send ether to a pre-determined address (one which you don’t own the private key to, but know that one of your accounts can create a contract to). You can send ether to that address and then retrieve the ether by later creating a contract which gets spawned over the same address. The constructor could be used to return all your pre-sent ether. Thus if someone where to obtain all your Ethereum private keys, it would be difficult for the attacker to discover that your Ethereum addresses also have access to this <em class="markup--em markup--p-em">hidden</em> ether. In fact, if the attacker spent too many transaction such that the nonce required to access your ether is used, it is impossible to recover your hidden ether.</p><p name="efe9" id="efe9" class="graf graf--p graf-after--p">Let me clarify this with a contract.</p><pre name="367f" id="367f" class="graf graf--pre graf-after--p">contract KeylessHiddenEthCreator { <br>    uint public currentContractNonce = 1; // keep track of this contracts nonce publicly (it&#39;s also found in the contracts state)</pre><pre name="a84a" id="a84a" class="graf graf--pre graf-after--pre">    // determine future addresses which can hide ether. <br>    function futureAddresses(uint8 nonce) public view returns (address) {<br>        if(nonce == 0) {<br>            return address(keccak256(0xd6, 0x94, this, 0x80));<br>        }<br>        return address(keccak256(0xd6, 0x94, this, nonce));<br>    // need to implement rlp encoding properly for a full range of nonces<br>    }<br>    <br>    // increment the contract nonce or retrieve ether from a hidden/key-less account<br>    // provided the nonce is correct<br>    function retrieveHiddenEther(address beneficiary) public returns (address) {<br>    currentContractNonce +=1;<br>       return new RecoverContract(beneficiary);<br>    }<br>    <br>    function () payable {} // Allow ether transfers (helps for playing in remix)<br>}</pre><pre name="33cf" id="33cf" class="graf graf--pre graf-after--pre">contract RecoverContract { <br>    constructor(address beneficiary) {<br>        selfdestruct(beneficiary); // don&#39;t deploy code. Return the ether stored here to the beneficiary. <br>    }<br> }</pre><p name="46c8" id="46c8" class="graf graf--p graf-after--pre">This contract allows you to store keyless ether (relatively safely, in the sense you can’t accidentally miss the nonce)[³]. The <code class="markup--code markup--p-code">futureAddresses()</code> function can be used to calculate the first 127 contract addresses that this contract can spawn, by specifying the <code class="markup--code markup--p-code">nonce</code>. If you send ether to one of these addresses, it can be later recovered by calling the <code class="markup--code markup--p-code">retrieveHiddenEther()</code> enough times. For example, if you choose <code class="markup--code markup--p-code">nonce=4</code> (and send ether to the associated address), you will need to call <code class="markup--code markup--p-code">retrieveHiddenEther()</code> four times and it will recover the ether to the <code class="markup--code markup--p-code">beneficiary</code> address.</p><p name="ec14" id="ec14" class="graf graf--p graf-after--p">This can be done without a contract. You can send ether to addresses that can be created from one of your standard Ethereum accounts and recover it later, at the correct nonce. Be careful however, if you accidentally surpass the transaction nonce that is required to recover your ether, your funds will be lost forever.</p><p name="0185" id="0185" class="graf graf--p graf-after--p">For more information on some more advanced tricks you can do with this quirk, I recommend reading <a href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" data-href="http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Martin Swende’s post</a>.</p><h3 name="a672" id="a672" class="graf graf--h3 graf-after--p">One Time Addresses</h3><p name="cea1" id="cea1" class="graf graf--p graf-after--h3">Ethereum transaction signing uses the Elliptic Curve Digital Signing Algorithm (ECDSA). Conventionally, in order to send a verified transaction on Ethereum, you sign a message with your Ethereum private key, which authorises spending from your account. In slightly more detail, the message that you sign is the components of the Ethereum transaction, specifically, the <code class="markup--code markup--p-code">to</code>, <code class="markup--code markup--p-code">value</code>, <code class="markup--code markup--p-code">gas</code>, <code class="markup--code markup--p-code">gasPrice</code>, <code class="markup--code markup--p-code">nonce</code> and <code class="markup--code markup--p-code">data</code> fields. The result of an Ethereum signature is three numbers, <code class="markup--code markup--p-code">v</code>, <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code>. I won&#39;t go into detail about what each of these represent, instead I refer the interested readers to the <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" data-href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">ECDSA wiki page</a>(which describes <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code>) and the <a href="https://ethereum.github.io/yellowpaper/paper.pdf" data-href="https://ethereum.github.io/yellowpaper/paper.pdf" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Ethereum Yellow Paper</a> (Appendix F - which describes <code class="markup--code markup--p-code">v</code>) and finally <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" data-href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">EIP155</a> for the current use of <code class="markup--code markup--p-code">v</code>.</p><p name="60d9" id="60d9" class="graf graf--p graf-after--p">So we know that an Ethereum transaction signature consists of a message and the numbers <code class="markup--code markup--p-code">v</code>, <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code>. We can check if a signature is valid, by using the message (i.e. transaction details), <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code> to derive an Ethereum address. If the derived Ethereum address matches the <code class="markup--code markup--p-code">from</code> field of the transaction, then we know that <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code> were created by someone who owns (or has access to) the private key for the <code class="markup--code markup--p-code">from</code> field and thus the signature is valid.</p><p name="4b3d" id="4b3d" class="graf graf--p graf-after--p">Consider now, that we don’t own a private key, but instead make up values for <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code> for an arbitrary transaction. Consider we have a transaction, with the parameters:</p><pre name="cfcf" id="cfcf" class="graf graf--pre graf-after--p">{to: &quot;0xa9e&quot;, value: 10e18, nonce: 0}</pre><p name="d0dd" id="d0dd" class="graf graf--p graf-after--pre">I’ve ignored the other parameters. This transaction will send 10 ether to the <code class="markup--code markup--p-code">0xa9e</code> address. Now lets say we make up some numbers <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code> (these have specific ranges) and a <code class="markup--code markup--p-code">v</code>. If we derive the Ethereum address related to these made up numbers we will get a random Ethereum address, lets call it <code class="markup--code markup--p-code">0x54321</code>. Knowing this address, we could send 10 ether to the <code class="markup--code markup--p-code">0x54321</code> address (without owning the private key for the address). At any point in the future, we could send the transaction,</p><pre name="bd6a" id="bd6a" class="graf graf--pre graf-after--p">{to: &quot;0xa9e&quot;, value: 10e18, nonce: 0, from: &quot;0x54321&quot;}</pre><p name="5656" id="5656" class="graf graf--p graf-after--pre">along with the signature, i.e. the <code class="markup--code markup--p-code">v</code>, <code class="markup--code markup--p-code">r</code> and <code class="markup--code markup--p-code">s</code> we made up. This will be a valid transaction, because the derived address will match our <code class="markup--code markup--p-code">from</code> field. This allows us to spend our money from this random address (<code class="markup--code markup--p-code">0x54321</code>) to the address we chose <code class="markup--code markup--p-code">0xa9e</code>. Thus we have managed to store ether in an address that we do not have the private key and used a one-time transaction to recover the ether.</p><p name="ea6a" id="ea6a" class="graf graf--p graf-after--p">This quirk can also be used to send ether to a large number of people in a trustless manner, as Nick Johnson describes in <a href="https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7" data-href="https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">How to send Ether to 11,440 people</a>.</p><h3 name="d4f2" id="d4f2" class="graf graf--h3 graf-after--p">Single Transaction Airdrops</h3><p name="ebdf" id="ebdf" class="graf graf--p graf-after--h3">An Airdrop refers to the process of distributing tokens amongst a large group of people. Traditionally, airdrops have been processed via a large number of transactions where each transaction updates either a single or a batch of user’s balances. This can be costly and strenuous on the Ethereum blockchain. There is an alternative method, in which many users balances can be credited with tokens using a single transaction.</p><p name="2b13" id="2b13" class="graf graf--p graf-after--p">This technique is explained in more detail by its proposer, RicMoo in his post: <a href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d" data-href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Merkle Air-Drops: Make Love, Not War</a>.</p><p name="92f3" id="92f3" class="graf graf--p graf-after--p">The idea is to create a <a href="https://en.wikipedia.org/wiki/Merkle_tree" data-href="https://en.wikipedia.org/wiki/Merkle_tree" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Merkle Tree</a> which contains (as leaf nodes) all the addresses and balances of users to be credited tokens. This will be done off-chain. The merkle tree can be given out publicly (again off-chain). A smart contract can then be created containing the root hash of the merkle tree which allows users to submit <a href="https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work" data-href="https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-work" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">merkle-proofs</a> to obtain their tokens. Thus a single transaction (the one used to create the contract, or to simply store the Merkle tree root hash), allows all credited users to redeem their airdropped tokens.</p><p name="92af" id="92af" class="graf graf--p graf-after--p">RicMoo in his <a href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d" data-href="https://blog.ricmoo.com/merkle-air-drops-e6406945584d" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">post</a> also provides an example of a function which can accept Merkle Proofs and credit a user’s balance:</p><pre name="1840" id="1840" class="graf graf--pre graf-after--p">function redeem(uint256 index, address recipient,<br>                uint256 amount, bytes32[] merkleProof) public {</pre><pre name="ac20" id="ac20" class="graf graf--pre graf-after--pre">    // Make sure this has not been redeemed<br>    uint256 redeemedBlock = _redeemed[index / 256];<br>    uint256 redeemedMask = (uint256(1) &lt;&lt; uint256(index % 256));<br>    require((redeemedBlock &amp; redeemedMask) == 0);</pre><pre name="2f9d" id="2f9d" class="graf graf--pre graf-after--pre">    // Mark it as redeemed (if we fail, we revert)<br>    _redeemed[index / 256] = redeemedBlock | redeemedMask;</pre><pre name="9adc" id="9adc" class="graf graf--pre graf-after--pre">    // Compute the merkle root from the merkle proof<br>    bytes32 node = keccak256(index, recipient, amount);<br>    uint256 path = index;<br>    for (uint16 i = 0; i &lt; merkleProof.length; i++) {<br>        if ((path &amp; 0x01) == 1) {<br>            node = keccak256(merkleProof[i], node);<br>        } else {<br>            node = keccak256(node, merkleProof[i]);<br>        }<br>        path /= 2;<br>    }</pre><pre name="ffa0" id="ffa0" class="graf graf--pre graf-after--pre">    // Check the resolved merkle proof matches our merkle root<br>    require(node == _rootHash);</pre><pre name="ee79" id="ee79" class="graf graf--pre graf-after--pre">    // Redeem!<br>    _balances[recipient] += amount;<br>    _totalSupply += amount;<br>    Transfer(0, recipient, amount);<br>}</pre><p name="55fd" id="55fd" class="graf graf--p graf-after--pre graf--trailing">This function could be built into a token contract to allow future airdrops. The only transaction required to credit all user’s balances, would be the transaction that sets the Merkle tree root.</p></div></div></section><section name="5788" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="52ab" id="52ab" class="graf graf--p graf--leading">Thanks for reading;)</p><figure name="e1ef" id="e1ef" class="graf graf--figure graf--layoutOutsetLeft graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 370px; max-height: 370px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 100%;"></div><img class="graf-image" data-image-id="1*PLw22EAlfu-TQhvLa6r4Yg.jpeg" data-width="370" data-height="370" src="https://cdn-images-1.medium.com/max/600/1*PLw22EAlfu-TQhvLa6r4Yg.jpeg"></div></figure><p name="ee7d" id="ee7d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">About the Author</strong></p><p name="3cad" id="3cad" class="graf graf--p graf-after--p"><a href="http://vaibhavsaini.com/" data-href="http://vaibhavsaini.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Vaibhav Saini</a> is a Co-Founder of <a href="http://towardsblockchain.com" data-href="http://towardsblockchain.com" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">TowardsBlockchain</em></strong></a><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">, </em></strong><em class="markup--em markup--p-em">an MIT Cambridge Innovation Center incubated startup.</em></p><p name="e0c8" id="e0c8" class="graf graf--p graf-after--p">He works as Senior blockchain developer and has worked on several blockchain platforms including Ethereum, Quorum, EOS, Nano, Hashgraph, IOTA.</p><p name="b36c" id="b36c" class="graf graf--p graf-after--p">He is currently a sophomore at <a href="http://www.iitd.ac.in/" data-href="http://www.iitd.ac.in/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">IIT Delhi</a>.</p><h4 name="dc58" id="dc58" class="graf graf--h4 graf-after--p">Learned something? Press and hold the 👏 to say “thanks!” and help others find this article.</h4><p name="abe6" id="abe6" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">Hold down the clap button if you liked the content! It helps me gain exposure .</em></p><p name="3a73" id="3a73" class="graf graf--p graf-after--p">Want to learn more? Checkout my previous articles.</p><div name="ce7c" id="ce7c" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://hackernoon.com/5-resources-to-get-started-with-ethereum-4fbf1b5aa57a" data-href="https://hackernoon.com/5-resources-to-get-started-with-ethereum-4fbf1b5aa57a" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/5-resources-to-get-started-with-ethereum-4fbf1b5aa57a"><strong class="markup--strong markup--mixtapeEmbed-strong">5 resources to get started with ethereum</strong><br><em class="markup--em markup--mixtapeEmbed-em">Ultimate guide for understanding &amp; starting with ethereum.</em>hackernoon.com</a><a href="https://hackernoon.com/5-resources-to-get-started-with-ethereum-4fbf1b5aa57a" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="63b8df3cc815941b8ff842716d466a9c" data-thumbnail-img-id="1*22qqVJZEn1bNI9R1_0z-Lw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*22qqVJZEn1bNI9R1_0z-Lw.png);"></a></div><div name="baf6" id="baf6" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://hackernoon.com/consensuspedia-an-encyclopedia-of-29-consensus-algorithms-e9c4b4b7d08f" data-href="https://hackernoon.com/consensuspedia-an-encyclopedia-of-29-consensus-algorithms-e9c4b4b7d08f" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/consensuspedia-an-encyclopedia-of-29-consensus-algorithms-e9c4b4b7d08f"><strong class="markup--strong markup--mixtapeEmbed-strong">ConsensusPedia: An Encyclopedia of 30 Consensus Algorithms</strong><br><em class="markup--em markup--mixtapeEmbed-em">A complete list of all consensus algorithms.</em>hackernoon.com</a><a href="https://hackernoon.com/consensuspedia-an-encyclopedia-of-29-consensus-algorithms-e9c4b4b7d08f" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="03bbca255c9ab55c0112e7879627edb3" data-thumbnail-img-id="0*y462aeJ4wg8HHYSs" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*y462aeJ4wg8HHYSs);"></a></div><div name="fc5f" id="fc5f" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://hackernoon.com/contractpedia-an-encyclopedia-of-40-smart-contract-platforms-4867f66da1e5" data-href="https://hackernoon.com/contractpedia-an-encyclopedia-of-40-smart-contract-platforms-4867f66da1e5" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/contractpedia-an-encyclopedia-of-40-smart-contract-platforms-4867f66da1e5"><strong class="markup--strong markup--mixtapeEmbed-strong">ContractPedia: An Encyclopedia of 40 Smart Contract Platforms</strong><br><em class="markup--em markup--mixtapeEmbed-em">A Complete List of all Smart Contract supportive Platforms</em>hackernoon.com</a><a href="https://hackernoon.com/contractpedia-an-encyclopedia-of-40-smart-contract-platforms-4867f66da1e5" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a949ea9028a00c3bb62dfc3f160efc92" data-thumbnail-img-id="0*zDyDSLiGCSPQHEMq.jpg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*zDyDSLiGCSPQHEMq.jpg);"></a></div><div name="5e6b" id="5e6b" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://hackernoon.com/difference-between-sidechains-and-state-channels-2f5dfbd10707" data-href="https://hackernoon.com/difference-between-sidechains-and-state-channels-2f5dfbd10707" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/difference-between-sidechains-and-state-channels-2f5dfbd10707"><strong class="markup--strong markup--mixtapeEmbed-strong">Difference between SideChains and State Channels</strong><br><em class="markup--em markup--mixtapeEmbed-em">A complete comparison of the two scaling methods.</em>hackernoon.com</a><a href="https://hackernoon.com/difference-between-sidechains-and-state-channels-2f5dfbd10707" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="096410b77bc232079dc957910f44555f" data-thumbnail-img-id="1*UmKkLx0_zCrwX1etzE-TRg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*UmKkLx0_zCrwX1etzE-TRg.jpeg);"></a></div><div name="8382" id="8382" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://hackernoon.com/eos-101-getting-started-with-eos-part-1-ab0324c233e0" data-href="https://hackernoon.com/eos-101-getting-started-with-eos-part-1-ab0324c233e0" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://hackernoon.com/eos-101-getting-started-with-eos-part-1-ab0324c233e0"><strong class="markup--strong markup--mixtapeEmbed-strong">EOS 101: Getting started with EOS, Part 1</strong><br><em class="markup--em markup--mixtapeEmbed-em">The only blockchain which has blocktime of less than a second: 0.5 sec!</em>hackernoon.com</a><a href="https://hackernoon.com/eos-101-getting-started-with-eos-part-1-ab0324c233e0" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fd8747ef4c18e7ed85fa1f826a789f6f" data-thumbnail-img-id="1*_BKG3utRCovL4A9s78vEpA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*_BKG3utRCovL4A9s78vEpA.png);"></a></div><p name="dd06" id="dd06" class="graf graf--p graf-after--mixtapeEmbed graf--trailing"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Clap 50 times and follow me on Twitter: </em></strong><a href="https://twitter.com/itsmattward" data-href="https://twitter.com/itsmattward" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener nofollow noopener noopener noopener noopener noopener noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">@</em></strong></a><a href="https://twitter.com/vasa_develop" data-href="https://twitter.com/vasa_develop" class="markup--anchor markup--p-anchor" rel="noopener nofollow nofollow noopener nofollow noopener noopener noopener noopener noopener noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">vasa_develop</em></strong></a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vaibhavsaini_67863" class="p-author h-card">vasa</a> on <a href="https://medium.com/p/f3210eba5148"><time class="dt-published" datetime="2018-07-23T02:36:01.127Z">July 23, 2018</time></a>.</p><p><a href="https://medium.com/@vaibhavsaini_67863/hackpedia-16-solidity-hacks-vulnerabilities-their-fixes-and-real-world-examples-f3210eba5148" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 19, 2019.</p></footer></article></body></html>